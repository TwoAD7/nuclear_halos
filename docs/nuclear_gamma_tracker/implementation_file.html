<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>nuclear_gamma_tracker.implementation_file API documentation</title>
<meta name="description" content="Summary â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nuclear_gamma_tracker.implementation_file</code></h1>
</header>
<section id="section-intro">
<p>Summary.</p>
<p>Written by: Roy Salinas</p>
<p>Main module to control automation in LISE++ with NSCL configuration file.
The implementation of the FRIB configuration file is yet to be developed.</p>
<p>Purpose: To retrive particular parameters from LISE++ such as beam intensity,
beam purity, wedge thickness, wedge angle, momentum acceptance, focal
plane slit width, and Image 2 slit width.</p>
<p>All beam data comes from NSCL website: <a href="https://nscl.msu.edu/users/beams.html">https://nscl.msu.edu/users/beams.html</a></p>
<p>Python version: 3.7.1
Currently, this is has only been tested on a Windows OS.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Summary.

Written by: Roy Salinas

Main module to control automation in LISE++ with NSCL configuration file.
The implementation of the FRIB configuration file is yet to be developed.

Purpose: To retrive particular parameters from LISE++ such as beam intensity,
beam purity, wedge thickness, wedge angle, momentum acceptance, focal
plane slit width, and Image 2 slit width.

All beam data comes from NSCL website: https://nscl.msu.edu/users/beams.html

Python version: 3.7.1
Currently, this is has only been tested on a Windows OS.
&#34;&#34;&#34;

import time
import csv
import os
import platform
import pyautogui as pag
import pyperclip as pc
import pandas as pd

&#34;&#34;&#34;
pixel locations for each isotope based on my screen (Resolution: 1920x1080)

Note: This can be improved to contain images of the isotope that appears on the screen.
Doing this rids the dependence on one&#39;s screen resolution and local pixel coordinates.
&#34;&#34;&#34;


#useros = platform.system()

#if useros == &#34;Linux&#34;:
#    print(&#34;Using a Linux OS...&#34;)
#    desktop = os.path.expanduser(&#34;~/Desktop&#34;)
#    print(f&#34;Your desktop path is: {desktop}&#34;)
#elif useros == &#34;Windows&#34;:
#print(&#34;Using a Windows OS...&#34;)

home = os.path.expanduser(&#39;~&#39;) #find your home directory 
desktop = home + &#34;\Desktop&#34;
print(f&#34;Your desktop path is {desktop}&#34;)


pixel_locations = {
    &#34;Mg_32&#34;: {
        &#34;x&#34;: 1121, &#34;y&#34;: 626}, &#34;Mg_33&#34;: {
            &#34;x&#34;: 1116, &#34;y&#34;: 626}, &#34;Mg_34&#34;: {
                &#34;x&#34;: 1116, &#34;y&#34;: 626}, &#34;Mg_35&#34;: {
                    &#34;x&#34;: 1116, &#34;y&#34;: 626}, &#34;Mg_36&#34;: {
                        &#34;x&#34;: 1136, &#34;y&#34;: 626}, &#34;Mg_37&#34;: {
                            &#34;x&#34;: 1116, &#34;y&#34;: 626}, &#34;Mg_38&#34;: {
                                &#34;x&#34;: 1116, &#34;y&#34;: 626}, &#34;Mg_40&#34;: {
                                    &#34;x&#34;: 1106, &#34;y&#34;: 626}}


&#34;&#34;&#34;
An array of dictionaries (c++ maps). &#34;data&#34; is the key for the corresponding isotope and
its value is an array of data. Using zeros as place holders for intialization.
&#34;&#34;&#34;
# array of maps, data is the key to the map, replace the zero&#39;s with arrays of data
# isotppe is one of the keys, data is the other key for that map with
# their corresponding values
isotope_info = [
    {&#34;isotope&#34;: &#34;Mg_32&#34;, &#34;data&#34;: 0.0},
    {&#34;isotope&#34;: &#34;Mg_33&#34;, &#34;data&#34;: 0.0},
    {&#34;isotope&#34;: &#34;Mg_34&#34;, &#34;data&#34;: 0.0},
    {&#34;isotope&#34;: &#34;Mg_35&#34;, &#34;data&#34;: 0.0},
    {&#34;isotope&#34;: &#34;Mg_36&#34;, &#34;data&#34;: 0.0},
    {&#34;isotope&#34;: &#34;Mg_37&#34;, &#34;data&#34;: 0.0},
    {&#34;isotope&#34;: &#34;Mg_38&#34;, &#34;data&#34;: 0.0},
    {&#34;isotope&#34;: &#34;Mg_40&#34;, &#34;data&#34;: 0.0}]

# dictionary of dictionary
beam_info = {
    &#34;O_16&#34;: {
        &#34;Energy&#34;: 150, &#34;Intensity&#34;: 175}, &#34;O_18&#34;: {
            &#34;Energy&#34;: 120, &#34;Intensity&#34;: 150}, &#34;Ne_20&#34;: {
                &#34;Energy&#34;: 170, &#34;Intensity&#34;: 80}, &#34;Ne_22&#34;: {
                    &#34;Energy&#34;: 150, &#34;Intensity&#34;: 100}, &#34;Mg_24&#34;: {
                        &#34;Energy&#34;: 170, &#34;Intensity&#34;: 60}, &#34;Si_28&#34;: {
                            &#34;Energy&#34;: 160, &#34;Intensity&#34;: 10}, &#34;S_32&#34;: {
                                &#34;Energy&#34;: 150, &#34;Intensity&#34;: 60}, &#34;Ar_36&#34;: {
                                    &#34;Energy&#34;: 150, &#34;Intensity&#34;: 75}, &#34;Ca_40&#34;: {
                                        &#34;Energy&#34;: 140, &#34;Intensity&#34;: 50}, &#34;Ca_48&#34;: {
                                            &#34;Energy&#34;: 90, &#34;Intensity&#34;: 15}, &#34;Ca_48&#34;: {
                                                &#34;Energy&#34;: 140, &#34;Intensity&#34;: 80}, &#34;Ni_58&#34;: {
                                                    &#34;Energy&#34;: 160, &#34;Intensity&#34;: 20}, &#34;Ni_64&#34;: {
                                                        &#34;Energy&#34;: 140, &#34;Intensity&#34;: 7}, &#34;Ge_76&#34;: {
                                                            &#34;Energy&#34;: 130, &#34;Intensity&#34;: 25}}


# Didn&#39;t include the rest of the beam list, intensity was too low to be
# significant.
&#34;&#34;&#34;
,   \
&#34;Se_82&#34;:{&#34;Energy&#34;:140,&#34;Intensity&#34;:45}, &#34;Kr_78&#34;:{&#34;Energy&#34;:150,&#34;Intensity&#34;:25},  \
&#34;Kr_86&#34;:{&#34;Energy&#34;:100,&#34;Intensity&#34;:15},&#34;Zr_96&#34;:{&#34;Energy&#34;:120,&#34;Intensity&#34;:3},    \
&#34;Mo_92&#34;:{&#34;Energy&#34;:140,&#34;Intensity&#34;:10}, &#34;Sn_112&#34;:{&#34;Energy&#34;:120,&#34;Intensity&#34;:4},  \
&#34;Sn_124&#34;:{&#34;Energy&#34;:120,&#34;Intensity&#34;:1.5} #incomplete but enough for our purposes
 }
&#34;&#34;&#34;

def notes():
    &#34;&#34;&#34;General Notes.

    If program is not open, look for the program image on deskotp, and click on it.

    Note: Could improve by having it go directly to the LISE++.exe file and executing it.
    Could do this with a shell script or here (in the python script).

    &#34;&#34;&#34;


def set_projectile(projectile_name, energy, intensity, A):
    &#34;&#34;&#34;Summary.

    Set the incoming projectile in LISE++ based on the projectiles name, energy,
    intensity, and atomic number (mass) A.
    Passed in to the arguments in the following order: projectile_name, energy,
    intensity, A.

    Current list of isotopes that can be used for target can be found at:
    https://nscl.msu.edu/users/beams.html

    &#34;&#34;&#34;
    print(&#34;Setting projectile...&#34;)
    pag.moveTo(16, 124)  # projectile button
    pag.click(interval=.5)
    pag.moveTo(262, 213)  # element text box
    pag.doubleClick()
    pag.write(projectile_name)
    pag.moveTo(231, 211)  # The mass number box
    pag.doubleClick()
    pag.write(str(A))
    pag.moveTo(519, 213)  # energy
    pag.doubleClick()
    pag.write(str(energy))
    pag.moveTo(523, 421)  # beam intensity
    pag.doubleClick()
    pag.write(str(intensity))
    pag.moveTo(269, 445)
    pag.click(interval=.5)
    time.sleep(1)

# to set the Focal Plane (FP) slits


def set_FP_slits(slit_width):
    &#34;&#34;&#34;Summary.

    Sets the the distance of the focal plane slits. The slit_width is passed in as the argument.
    Important to set the appropriate Focal Plane (FP) slits to be able to achieve a compromise
    between the purity of the beam and yield.

    &#34;&#34;&#34;
    print(&#34;Setting FP_Slits...&#34;)
    pag.moveTo(65, 684)  # move to slit button
    pag.click()
    pag.moveTo(764, 231)
    pag.click()
    pag.write(str(slit_width))
    pag.moveTo(238, 447)
    pag.click()
    pag.moveTo(71, 744)
    pag.click()

# to set the wedge thickness


def set_I2_wedge(wedge_thickness):
    &#34;&#34;&#34;Summary.

    Use to set the thickness of the wedge at the second image plane &#39;I2&#39;.
    Important due to the magnets adjusting to the wedge with the appropriate
    Brho value to maximize the transmission of the fragment
    you are interested and reduce the amount of contaminants.

    &#34;&#34;&#34;
    print(&#34;Setting I2_wedge...&#34;)
    pag.moveTo(60, 461)  # move to wedge button
    pag.click(interval=1)
    pag.write(str(wedge_thickness))
    pag.moveTo(926, 223)  # set spectrometer after block
    pag.click(interval=1)
    time.sleep(2)
    pag.moveTo(397, 398)  # select wedge profile
    pag.click(interval=1)
    pag.moveTo(881, 394)  # move to calculate angle
    pag.click()
    time.sleep(10)  # wait
    pag.moveTo(371, 479)  # fit achromatic angle from LISE calc.
    pag.click()
    pag.moveTo(308, 530)  # select the angle and copy
    pag.doubleClick()
    pc.copy(&#34;&#34;)
    time.sleep(2)
    # done twice due to bug in not properly copying. This fixes that bug.
    pag.hotkey(&#39;ctrl&#39;, &#39;c&#39;)
    time.sleep(1)
    pag.hotkey(&#39;ctrl&#39;, &#39;c&#39;)
    angle = pc.paste()
    pag.moveTo(168, 622)  # ok button
    pag.click()
    pag.moveTo(152, 535)
    pag.click()
    print(f&#34;The angle for the wedge is -{angle}.&#34;)
    return str(angle)


def tune_spectrometer():
    &#34;&#34;&#34;Tune the overall spectrometer to optimize transmission. Done by LISE++.&#34;&#34;&#34;
    print(&#34;Tuning spectrometer...&#34;)
    pag.moveTo(335, 78)
    pag.click()
    time.sleep(1)


def set_fragment(fragment, A):
    &#34;&#34;&#34;Summary.

    Set the fragment you are interested in studying. Pass in the name of the
    fragment and mass number A.
    This is handled automatically in the loop, no need to set it
    yourself (besided debugging/upgrading reasons).

    &#34;&#34;&#34;
    print(&#34;Setting fragment...&#34;)
    pag.moveTo(20, 170)  # projectile button
    pag.click()
    pag.moveTo(250, 463)  # element text box
    pag.doubleClick()
    # pag.press(&#34;delete&#34;)
    pag.write(str(A))
    pag.moveTo(309, 470)  # element text box
    pag.doubleClick()
    # pag.press(&#34;delete&#34;)
    pag.write(fragment)
    pag.moveTo(624, 521)  # energy
    pag.click()
    time.sleep(1)

# to retrive the thickness


def get_thickness():
    &#34;&#34;&#34;To retrive the thickness of the target after optmizing. Optimizing is done by LISE++.&#34;&#34;&#34;
    target_thickness = 0
    pc.copy(&#34;&#34;)  # clear clipboard
    print(&#34;Retrieving thickness...&#34;)
    pag.moveTo(453, 38)  # calculations
    pag.click(interval=1)
    pag.dragTo(504, 151, .5)  # Optimum target
    time.sleep(1)
    pag.moveTo(381, 485)  # first ok
    pag.click(interval=1.5)
    pag.moveTo(326, 655)  # second ok
    pag.click(interval=1.5)
    time.sleep(20)
    pag.moveTo(260, 451)  # load thickness
    pag.click()
    pag.moveTo(1629, 160)  # exit first plot
    pag.click()
    pag.moveTo(1600, 93)  # exit second plot
    pag.click()
    pag.moveTo(24, 196)  # target button
    pag.click()
    pag.moveTo(477, 286)  # box containing info
    time.sleep(1)
    pag.doubleClick()
    time.sleep(1)
    pag.hotkey(&#39;ctrl&#39;, &#39;c&#39;)  # copy
    time.sleep(1)
    target_thickness = pc.paste()  # paste it to a variable
    print(f&#34;Thickness is {target_thickness} microns&#34;)
    pag.moveTo(456, 459)  # ok button to close
    pag.click()
    return target_thickness

# to retrive intensity
def get_intensity(isotope, beam_element, beam_mass):
    &#34;&#34;&#34;Summary.

    Retrieve the intensity based on the isotope you are interested in,
    the beam isotope (element) you are using, and the mass number
    for the beam element.
    &#34;&#34;&#34;
    flag = False
    print(isotope)
    # get pixel location of isotope on screen
    print(&#34;Retrieving intensity...&#34;)
    x = pixel_locations[isotope][&#34;x&#34;]
    y = pixel_locations[isotope][&#34;y&#34;]
    # print(x,y)
    pag.position()
    pag.moveTo(x, y)
    pag.click(button=&#34;right&#34;,interval=1)
    pag.moveTo(1483, 417)  # File save button
    pag.click()
    pag.moveTo(531, 339)  # file save text box
    pag.click(interval=1)
    # desktop comes from top of the sript.
    filename = str(desktop) + r&#34;\data.txt&#34;
    print(f&#34;The file is being saved at the following location: {filename}&#34;)
    pag.write(filename)
    # pag.write(&#34;junk.txt&#34;)
    pag.press(&#34;enter&#34;)
    pag.press(&#34;left&#34;)
    pag.press(&#34;enter&#34;)  # this &#34;enter&#34; saves the file to desktop
    pag.moveTo(1563, 44)
    pag.click()
    df = pd.read_csv(filename)
    # df = pd.read_csv(&#34;C:\\Users\Owner\Desktop\junk.txt&#34;) #path to temporary file. NEED TO UPDATE
    # print(df)
    # location of the intensity in the data frame. Usually included an extra
    # line if it is zero
    intensity_check = df.iloc[0, 0]
    intensity_check = intensity_check.split()
    print(intensity_check)
    if len(intensity_check) == 6:
        if intensity_check[5] == &#34;0!&#34;:
            print(&#34;TRANSMISSION IS 0.0% WITH THIS PROJECTILE &#34;)
            flag = True
            return 0, flag
    else:
        # location of the intensity in the data frame
        _intensity = df.iloc[6, 0]
        _intensity = _intensity.split()
        # intensity value
        print(
            f&#34;The intensity for {isotope} with {beam_element} {beam_mass} is {_intensity[4]} pps.&#34;)
        return _intensity[4], flag

# retrieve the transmission in X-space


def FP_slit_X_transmission_percent():
    &#34;&#34;&#34;Summary.

    Retrieve the transmission percent in the x direction at the focal plane.
    Incoming beam looks &#39;Gaussian&#39; but
    there is very litter dispersion in y direction.
    &#34;&#34;&#34;
    # NEED TO WORK ON THIS
    print(&#34;Getting FP_Slits X space transmission...&#34;)
    # desktop comes from top of the sript.
    filename = str(desktop) + r&#34;\data.txt&#34;
    df = pd.read_csv(filename)
    FP_x_space_transmission = df.iloc[39, 0]  # location in the .csv file
    FP_x_space_transmission = FP_x_space_transmission.split()
    # print(FP_x_space_transmission[4])
    return FP_x_space_transmission[4]  # percent value


def purity_percent(fragment_isotope):
    &#34;&#34;&#34;Summary.

    Retrieve the overall purity for the fragment you are studying after
     passinng through the FP_PIN (focal plane Particle in) detector.

    &#34;&#34;&#34;
    print(f&#34;Retrieving beam purity for {fragment_isotope}...&#34;)
    pag.moveTo(832, 83)  # run all nucleo buttom (red lightning bolt)
    pag.click()
    time.sleep(40)
    pag.moveTo(999, 77)  # x spatial distribution
    pag.click()
    pag.dragTo(1110, 629, .5)  # FP_PIN detector
    pag.click(interval=.5)
    time.sleep(4)
    pag.moveTo(14, 316)  # stats box
    pag.click()
    pag.press(&#34;enter&#34;)  # accept
    time.sleep(1)
    pag.moveTo(1609, 201)  # file save button
    pag.click()
    &#34;&#34;&#34;
        pag.moveTo(365,195) #drop down
        pag.click()
        #pag.press(&#34;d&#34;,presses=2,interval=1) #to save in desktop
        pag.press(&#34;d&#34;,interval=1) #to save in desktop
        pag.press(&#34;enter&#34;)
        &#34;&#34;&#34;
    pag.moveTo(389, 413)  # file save text box
    pag.click()

    # desktop comes from top of the sript.
    filename = str(desktop) + r&#34;\pps_data.txt&#34;
    print(f&#34;The file is being saved at the following location: {filename}&#34;)
    pag.write(filename)

    # pag.write(&#34;pps_junk.txt&#34;)
    pag.press(&#34;enter&#34;)  # save file
    pag.press(&#34;left&#34;)
    pag.press(&#34;enter&#34;)  # this &#34;enter&#34; saves the file to desktop
    pag.moveTo(1682, 122)
    pag.click()
    pag.moveTo(1877, 13)
    pag.click()
    df = pd.read_csv(filename, error_bad_lines=False)
    # df =
    # pd.read_csv(&#34;C:\\Users\Owner\Desktop\pps_junk.txt&#34;,error_bad_lines=False)
    # #path to temporary file. NEED TO UPDATE
    #print(f&#34;Size of data frame is {df.size}.&#34;)
    _string = df.iloc[5, 0]  # get the pps for isotope in question
    _string = _string.split()
    isotope_fragment = _string[13]  # grab pps value
    total = 0.
    for i in range(5, df.size):
        string = df.iloc[i, 0]
        string = string.split()
        # to get it to correct scientific notation
        val = float(float(string[13]))
        total = total + val
    print(f&#34;The total amount of pps is {total}.&#34;)
    frag_val = float(float(isotope_fragment))
    print(
        f&#34;Percent of {fragment_isotope} in beam is {(float(float(frag_val))/total)*100.} %&#34;)
    percent = (float(float(frag_val)) / total) * 100.
    return percent


def isotope_loop():
    &#34;&#34;&#34;Summary.

    Use to find the best beam for each isotope. However, it
    has already been determined that the best beam is Ca 48.
    &#34;&#34;&#34;
    beam_data = []
    start = time.time()
    df = pd.DataFrame(None)  # create our data frame
    for i, dic in enumerate(isotope_info):  # loop for fragments
        df = df[0:0]
        df = pd.DataFrame(
            columns=[
                &#34;Beam element&#34;,
                &#34;A (u)&#34;,
                &#34;Beam energy (MeV/u)&#34;,
                &#34;Beam Intensity (pnA)&#34;,
                &#34;Target thickness (microns)&#34;,
                &#34;Fragment Intensity (pnA)&#34;])
        data = []
        # get rid of the underscore in the isotope name
        iso = dic[&#39;isotope&#39;].replace(&#34;_&#34;, &#34; &#34;)
        # returns the name of the isotope
        print(f&#34;You are looking at the {iso} isotope.&#34;)
        iso = iso.split()
        set_fragment(iso[0], iso[1])  # fragment name, mass number
        # now loop for all the provided beams
        for i, beam_element in enumerate(
                beam_info):
            print(
                f&#34;You are using {beam_element} as your primary beam at \
                {beam_info[beam_element][&#39;Energy&#39;]} MeV/u with \
                {beam_info[beam_element][&#39;Intensity&#39;]} pnA.&#34;)
            beam_energy = beam_info[beam_element][&#34;Energy&#34;]
            beam_intensity = beam_info[beam_element][&#34;Intensity&#34;]
            beam_element = beam_element.replace(&#34;_&#34;, &#34; &#34;)
            beam_element = beam_element.split()
            if beam_element[1] &lt;= iso[1]:
                print(
                    f&#34;Skipping {beam_element[0]} {beam_element[1]}. Not greater\
                     than {iso[1]} nucleons.&#34;)
                continue
            #                           name, energy, intensity, mass number A
            set_projectile(
                beam_element[0],
                beam_energy,
                beam_intensity,
                beam_element[1])
            # thickness with that particular beam for a particular fragment
            thickness = get_thickness()
            tune_spectrometer()
            # pass the isotope name to get intensity and save it to the map
            # with the frag info
            frag_intensity, flag = get_intensity(
                dic[&#39;isotope&#39;], beam_element[0], beam_element[1])
            if flag:
                continue
            print(
                f&#34;Data being appended in the following format -&gt; beam element, \
                A,beam energy, beam intensity, thickness, fragment intensity: \
                {beam_element[0]},{beam_element[1]} ,{beam_energy},{beam_intensity},\
                {thickness}, {frag_intensity}&#34;)
            df.loc[i] = [
                beam_element[0],
                beam_element[1],
                beam_energy,
                beam_intensity,
                thickness,
                frag_intensity]
            print(df)
        print(f&#34;DATA FRAME FOR {iso[0]} {iso[1]} ISOTOPE.&#34;)
        print(df)
        df.to_csv(f&#34;{iso[0]}_{iso[1]}_data_LISE++.csv&#34;)
        print(f&#34;File saved as: {iso[0]}_{iso[1]}_data_LISE++.csv&#34;)
    end = time.time()
    print(f&#34;It took {end-start} to run everything.&#34;)


def slice_array(arr, start):
    &#34;&#34;&#34;Summary.

    To &#34;slice&#34; an array of dictionaries and return sliced array.

    Function to slice an array. Pass in the array and where you want to begin slicing from.
    &#34;&#34;&#34;
    new_array = []
    index = 0
    for i, dic in enumerate(arr):
        # grab individual dictionary in that specific array index
        temp_dic = arr[i]
        if temp_dic[&#34;isotope&#34;] == str(
                start):  # if starting isotope is found, save the index location
            index = i
            break
    for t in range(index, len(arr)):
        new_array.append(arr[t])
    return new_array  # return a sliced array containing dictionaries from starting isotope


def isotope_tuning_values(
        FP_slit_width,
        isotope_start,
        isotope_end,
        wedge_range):
    &#34;&#34;&#34;To find the best configuration using a Ca 48 beam.&#34;&#34;&#34;
    set_projectile(&#34;Ca&#34;,140,80,48)  # set the beam here with element name, energy, intensity, atomic number
    start = time.time()
    set_FP_slits(FP_slit_width)
    # if bool_value == True: #if you want to start from  a particular isotope
    new_isotope_dic = slice_array(isotope_info, isotope_start)
    for i, dic in enumerate(new_isotope_dic):  # loop for each fragment
        df = pd.DataFrame(None)  # create our data frame
        df = pd.DataFrame(
            columns=[
                &#34;I_2 slit width (mm) &#34;,
                &#34;Intensity (pps) &#34;,
                &#34;Target thickness (microns) &#34;,
                &#34;Horizontal FP Slit width (mm)&#34;,
                &#34;Purity transmission % &#34;,
                &#34;Mom. Accpetance % &#34;,
                &#34;Wedge thickness (microns) &#34;,
                &#34;wedge angle (mrad)&#34;])
        # get rid of the underscore in the isotope name
        iso = dic[&#39;isotope&#39;].replace(&#34;_&#34;, &#34; &#34;)
        # returns the name of the isotope
        print(f&#34;You are looking at the {iso} isotope.&#34;)
        iso = iso.split()
        set_fragment(iso[0], iso[1])
        # wedge_thickness = 2300 #wedge thickness to start with
        for count, wedge_thickness in enumerate(
                wedge_range):  # loop over each wedge thickness
            print(
                f&#34;Currently using {wedge_thickness} microns for {iso[0]} {iso[1]}&#34;)
            tune_spectrometer()
            # There is a dependence between target and wedge. Doing it twice
            # gives best results
            preliminary_wedge_angle = set_I2_wedge(str(wedge_thickness))
            tune_spectrometer()
            preliminary_target_thickness = get_thickness()
            tune_spectrometer()
            wedge_angle = set_I2_wedge(str(wedge_thickness))
            wedge_angle = &#34;-&#34; + wedge_angle
            tune_spectrometer()
            target_thickness = get_thickness()
            tune_spectrometer()
            # pass the isotope name to get intensity and save it to the map
            # with the frag info
            frag_intensity, flag = get_intensity(dic[&#39;isotope&#39;], &#34;Ca&#34;, 48)
            if flag:  # if we have zero transmission, skip that wedge thickness
                continue
            #FP_x_space_transmission = FP_slit_X_transmission_percent()
            # pass in the name of the fragment isotope
            _purity_percent = purity_percent(iso[0] + iso[1])
            print(f&#34;Purity is {_purity_percent} %&#34;)
            df.loc[count] = [
                29.5,
                frag_intensity,
                target_thickness,
                FP_slit_width,
                _purity_percent,
                1,
                wedge_thickness,
                wedge_angle]  # harcode the 1% momentum acceptance
            wedge_thickness = wedge_thickness + 100
            print(f&#34;Have gone through {count} iterations&#34;)
            print(df)

        path = os.path.join(&#34;.&#34;,&#34;data_files&#34;)
        directory_check = os.path.isdir(path)
        if directory_check == True:
            print(&#34;Hey&#34;)
            df.to_csv(f&#34;./{path}/{iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)
            print(f&#34;File saved in {path} as: {iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)
        if directory_check == False:
            print(f&#34;Creating the following directory {path}&#34;)
            os.mkdir(path) 
            df.to_csv(f&#34;./{path}/{iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)
            print(f&#34;File saved in {path} as: {iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)

        #df.to_csv(
         #   f&#34;./{path}/{iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)
        #print(
        #    f&#34;File saved as: {iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)
        del df
        if dic[&#39;isotope&#39;] == isotope_end:
            print(f&#34;YOU HAVE REACHED {isotope_end}!&#34;)
            break
    end = time.time()
    print(f&#34;It took {(end-start)/60.0} minutes to run everything.&#34;)


def save():
    &#34;&#34;&#34;Save the thickness to a text file.&#34;&#34;&#34;
    with open(&#34;thickness.txt&#34;, &#34;w&#34;) as file:
        file.write(json.dumps(isotope_info))
    file.close()

# python 3 version


def show_pixels():
    &#34;&#34;&#34;Show the pixel location on your screen as you move your cursor.&#34;&#34;&#34;
    print(&#39;Press Ctrl-C to quit.&#39;)
    try:
        while True:
            x, y = pag.position()
            positionStr = &#39;X: &#39; + str(x).rjust(4) + &#39; Y: &#39; + str(y).rjust(4)
            print(positionStr, end=&#39;&#39;)
            print(&#39;\b&#39; * len(positionStr), end=&#39;&#39;, flush=True)
    except KeyboardInterrupt:
        print(&#39;\n&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="nuclear_gamma_tracker.implementation_file.beam_info"><code class="name">var <span class="ident">beam_info</span></code></dt>
<dd>
<div class="desc"><p>,
"Se_82":{"Energy":140,"Intensity":45}, "Kr_78":{"Energy":150,"Intensity":25},
"Kr_86":{"Energy":100,"Intensity":15},"Zr_96":{"Energy":120,"Intensity":3},
"Mo_92":{"Energy":140,"Intensity":10}, "Sn_112":{"Energy":120,"Intensity":4},
"Sn_124":{"Energy":120,"Intensity":1.5} #incomplete but enough for our purposes
}</p></div>
</dd>
<dt id="nuclear_gamma_tracker.implementation_file.pixel_locations"><code class="name">var <span class="ident">pixel_locations</span></code></dt>
<dd>
<div class="desc"><p>An array of dictionaries (c++ maps). "data" is the key for the corresponding isotope and
its value is an array of data. Using zeros as place holders for intialization.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="nuclear_gamma_tracker.implementation_file.FP_slit_X_transmission_percent"><code class="name flex">
<span>def <span class="ident">FP_slit_X_transmission_percent</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary.</p>
<p>Retrieve the transmission percent in the x direction at the focal plane.
Incoming beam looks 'Gaussian' but
there is very litter dispersion in y direction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FP_slit_X_transmission_percent():
    &#34;&#34;&#34;Summary.

    Retrieve the transmission percent in the x direction at the focal plane.
    Incoming beam looks &#39;Gaussian&#39; but
    there is very litter dispersion in y direction.
    &#34;&#34;&#34;
    # NEED TO WORK ON THIS
    print(&#34;Getting FP_Slits X space transmission...&#34;)
    # desktop comes from top of the sript.
    filename = str(desktop) + r&#34;\data.txt&#34;
    df = pd.read_csv(filename)
    FP_x_space_transmission = df.iloc[39, 0]  # location in the .csv file
    FP_x_space_transmission = FP_x_space_transmission.split()
    # print(FP_x_space_transmission[4])
    return FP_x_space_transmission[4]  # percent value</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.implementation_file.get_intensity"><code class="name flex">
<span>def <span class="ident">get_intensity</span></span>(<span>isotope, beam_element, beam_mass)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary.</p>
<p>Retrieve the intensity based on the isotope you are interested in,
the beam isotope (element) you are using, and the mass number
for the beam element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_intensity(isotope, beam_element, beam_mass):
    &#34;&#34;&#34;Summary.

    Retrieve the intensity based on the isotope you are interested in,
    the beam isotope (element) you are using, and the mass number
    for the beam element.
    &#34;&#34;&#34;
    flag = False
    print(isotope)
    # get pixel location of isotope on screen
    print(&#34;Retrieving intensity...&#34;)
    x = pixel_locations[isotope][&#34;x&#34;]
    y = pixel_locations[isotope][&#34;y&#34;]
    # print(x,y)
    pag.position()
    pag.moveTo(x, y)
    pag.click(button=&#34;right&#34;,interval=1)
    pag.moveTo(1483, 417)  # File save button
    pag.click()
    pag.moveTo(531, 339)  # file save text box
    pag.click(interval=1)
    # desktop comes from top of the sript.
    filename = str(desktop) + r&#34;\data.txt&#34;
    print(f&#34;The file is being saved at the following location: {filename}&#34;)
    pag.write(filename)
    # pag.write(&#34;junk.txt&#34;)
    pag.press(&#34;enter&#34;)
    pag.press(&#34;left&#34;)
    pag.press(&#34;enter&#34;)  # this &#34;enter&#34; saves the file to desktop
    pag.moveTo(1563, 44)
    pag.click()
    df = pd.read_csv(filename)
    # df = pd.read_csv(&#34;C:\\Users\Owner\Desktop\junk.txt&#34;) #path to temporary file. NEED TO UPDATE
    # print(df)
    # location of the intensity in the data frame. Usually included an extra
    # line if it is zero
    intensity_check = df.iloc[0, 0]
    intensity_check = intensity_check.split()
    print(intensity_check)
    if len(intensity_check) == 6:
        if intensity_check[5] == &#34;0!&#34;:
            print(&#34;TRANSMISSION IS 0.0% WITH THIS PROJECTILE &#34;)
            flag = True
            return 0, flag
    else:
        # location of the intensity in the data frame
        _intensity = df.iloc[6, 0]
        _intensity = _intensity.split()
        # intensity value
        print(
            f&#34;The intensity for {isotope} with {beam_element} {beam_mass} is {_intensity[4]} pps.&#34;)
        return _intensity[4], flag</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.implementation_file.get_thickness"><code class="name flex">
<span>def <span class="ident">get_thickness</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>To retrive the thickness of the target after optmizing. Optimizing is done by LISE++.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_thickness():
    &#34;&#34;&#34;To retrive the thickness of the target after optmizing. Optimizing is done by LISE++.&#34;&#34;&#34;
    target_thickness = 0
    pc.copy(&#34;&#34;)  # clear clipboard
    print(&#34;Retrieving thickness...&#34;)
    pag.moveTo(453, 38)  # calculations
    pag.click(interval=1)
    pag.dragTo(504, 151, .5)  # Optimum target
    time.sleep(1)
    pag.moveTo(381, 485)  # first ok
    pag.click(interval=1.5)
    pag.moveTo(326, 655)  # second ok
    pag.click(interval=1.5)
    time.sleep(20)
    pag.moveTo(260, 451)  # load thickness
    pag.click()
    pag.moveTo(1629, 160)  # exit first plot
    pag.click()
    pag.moveTo(1600, 93)  # exit second plot
    pag.click()
    pag.moveTo(24, 196)  # target button
    pag.click()
    pag.moveTo(477, 286)  # box containing info
    time.sleep(1)
    pag.doubleClick()
    time.sleep(1)
    pag.hotkey(&#39;ctrl&#39;, &#39;c&#39;)  # copy
    time.sleep(1)
    target_thickness = pc.paste()  # paste it to a variable
    print(f&#34;Thickness is {target_thickness} microns&#34;)
    pag.moveTo(456, 459)  # ok button to close
    pag.click()
    return target_thickness</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.implementation_file.isotope_loop"><code class="name flex">
<span>def <span class="ident">isotope_loop</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary.</p>
<p>Use to find the best beam for each isotope. However, it
has already been determined that the best beam is Ca 48.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isotope_loop():
    &#34;&#34;&#34;Summary.

    Use to find the best beam for each isotope. However, it
    has already been determined that the best beam is Ca 48.
    &#34;&#34;&#34;
    beam_data = []
    start = time.time()
    df = pd.DataFrame(None)  # create our data frame
    for i, dic in enumerate(isotope_info):  # loop for fragments
        df = df[0:0]
        df = pd.DataFrame(
            columns=[
                &#34;Beam element&#34;,
                &#34;A (u)&#34;,
                &#34;Beam energy (MeV/u)&#34;,
                &#34;Beam Intensity (pnA)&#34;,
                &#34;Target thickness (microns)&#34;,
                &#34;Fragment Intensity (pnA)&#34;])
        data = []
        # get rid of the underscore in the isotope name
        iso = dic[&#39;isotope&#39;].replace(&#34;_&#34;, &#34; &#34;)
        # returns the name of the isotope
        print(f&#34;You are looking at the {iso} isotope.&#34;)
        iso = iso.split()
        set_fragment(iso[0], iso[1])  # fragment name, mass number
        # now loop for all the provided beams
        for i, beam_element in enumerate(
                beam_info):
            print(
                f&#34;You are using {beam_element} as your primary beam at \
                {beam_info[beam_element][&#39;Energy&#39;]} MeV/u with \
                {beam_info[beam_element][&#39;Intensity&#39;]} pnA.&#34;)
            beam_energy = beam_info[beam_element][&#34;Energy&#34;]
            beam_intensity = beam_info[beam_element][&#34;Intensity&#34;]
            beam_element = beam_element.replace(&#34;_&#34;, &#34; &#34;)
            beam_element = beam_element.split()
            if beam_element[1] &lt;= iso[1]:
                print(
                    f&#34;Skipping {beam_element[0]} {beam_element[1]}. Not greater\
                     than {iso[1]} nucleons.&#34;)
                continue
            #                           name, energy, intensity, mass number A
            set_projectile(
                beam_element[0],
                beam_energy,
                beam_intensity,
                beam_element[1])
            # thickness with that particular beam for a particular fragment
            thickness = get_thickness()
            tune_spectrometer()
            # pass the isotope name to get intensity and save it to the map
            # with the frag info
            frag_intensity, flag = get_intensity(
                dic[&#39;isotope&#39;], beam_element[0], beam_element[1])
            if flag:
                continue
            print(
                f&#34;Data being appended in the following format -&gt; beam element, \
                A,beam energy, beam intensity, thickness, fragment intensity: \
                {beam_element[0]},{beam_element[1]} ,{beam_energy},{beam_intensity},\
                {thickness}, {frag_intensity}&#34;)
            df.loc[i] = [
                beam_element[0],
                beam_element[1],
                beam_energy,
                beam_intensity,
                thickness,
                frag_intensity]
            print(df)
        print(f&#34;DATA FRAME FOR {iso[0]} {iso[1]} ISOTOPE.&#34;)
        print(df)
        df.to_csv(f&#34;{iso[0]}_{iso[1]}_data_LISE++.csv&#34;)
        print(f&#34;File saved as: {iso[0]}_{iso[1]}_data_LISE++.csv&#34;)
    end = time.time()
    print(f&#34;It took {end-start} to run everything.&#34;)</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.implementation_file.isotope_tuning_values"><code class="name flex">
<span>def <span class="ident">isotope_tuning_values</span></span>(<span>FP_slit_width, isotope_start, isotope_end, wedge_range)</span>
</code></dt>
<dd>
<div class="desc"><p>To find the best configuration using a Ca 48 beam.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isotope_tuning_values(
        FP_slit_width,
        isotope_start,
        isotope_end,
        wedge_range):
    &#34;&#34;&#34;To find the best configuration using a Ca 48 beam.&#34;&#34;&#34;
    set_projectile(&#34;Ca&#34;,140,80,48)  # set the beam here with element name, energy, intensity, atomic number
    start = time.time()
    set_FP_slits(FP_slit_width)
    # if bool_value == True: #if you want to start from  a particular isotope
    new_isotope_dic = slice_array(isotope_info, isotope_start)
    for i, dic in enumerate(new_isotope_dic):  # loop for each fragment
        df = pd.DataFrame(None)  # create our data frame
        df = pd.DataFrame(
            columns=[
                &#34;I_2 slit width (mm) &#34;,
                &#34;Intensity (pps) &#34;,
                &#34;Target thickness (microns) &#34;,
                &#34;Horizontal FP Slit width (mm)&#34;,
                &#34;Purity transmission % &#34;,
                &#34;Mom. Accpetance % &#34;,
                &#34;Wedge thickness (microns) &#34;,
                &#34;wedge angle (mrad)&#34;])
        # get rid of the underscore in the isotope name
        iso = dic[&#39;isotope&#39;].replace(&#34;_&#34;, &#34; &#34;)
        # returns the name of the isotope
        print(f&#34;You are looking at the {iso} isotope.&#34;)
        iso = iso.split()
        set_fragment(iso[0], iso[1])
        # wedge_thickness = 2300 #wedge thickness to start with
        for count, wedge_thickness in enumerate(
                wedge_range):  # loop over each wedge thickness
            print(
                f&#34;Currently using {wedge_thickness} microns for {iso[0]} {iso[1]}&#34;)
            tune_spectrometer()
            # There is a dependence between target and wedge. Doing it twice
            # gives best results
            preliminary_wedge_angle = set_I2_wedge(str(wedge_thickness))
            tune_spectrometer()
            preliminary_target_thickness = get_thickness()
            tune_spectrometer()
            wedge_angle = set_I2_wedge(str(wedge_thickness))
            wedge_angle = &#34;-&#34; + wedge_angle
            tune_spectrometer()
            target_thickness = get_thickness()
            tune_spectrometer()
            # pass the isotope name to get intensity and save it to the map
            # with the frag info
            frag_intensity, flag = get_intensity(dic[&#39;isotope&#39;], &#34;Ca&#34;, 48)
            if flag:  # if we have zero transmission, skip that wedge thickness
                continue
            #FP_x_space_transmission = FP_slit_X_transmission_percent()
            # pass in the name of the fragment isotope
            _purity_percent = purity_percent(iso[0] + iso[1])
            print(f&#34;Purity is {_purity_percent} %&#34;)
            df.loc[count] = [
                29.5,
                frag_intensity,
                target_thickness,
                FP_slit_width,
                _purity_percent,
                1,
                wedge_thickness,
                wedge_angle]  # harcode the 1% momentum acceptance
            wedge_thickness = wedge_thickness + 100
            print(f&#34;Have gone through {count} iterations&#34;)
            print(df)

        path = os.path.join(&#34;.&#34;,&#34;data_files&#34;)
        directory_check = os.path.isdir(path)
        if directory_check == True:
            print(&#34;Hey&#34;)
            df.to_csv(f&#34;./{path}/{iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)
            print(f&#34;File saved in {path} as: {iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)
        if directory_check == False:
            print(f&#34;Creating the following directory {path}&#34;)
            os.mkdir(path) 
            df.to_csv(f&#34;./{path}/{iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)
            print(f&#34;File saved in {path} as: {iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)

        #df.to_csv(
         #   f&#34;./{path}/{iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)
        #print(
        #    f&#34;File saved as: {iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)
        del df
        if dic[&#39;isotope&#39;] == isotope_end:
            print(f&#34;YOU HAVE REACHED {isotope_end}!&#34;)
            break
    end = time.time()
    print(f&#34;It took {(end-start)/60.0} minutes to run everything.&#34;)</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.implementation_file.notes"><code class="name flex">
<span>def <span class="ident">notes</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>General Notes.</p>
<p>If program is not open, look for the program image on deskotp, and click on it.</p>
<p>Note: Could improve by having it go directly to the LISE++.exe file and executing it.
Could do this with a shell script or here (in the python script).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notes():
    &#34;&#34;&#34;General Notes.

    If program is not open, look for the program image on deskotp, and click on it.

    Note: Could improve by having it go directly to the LISE++.exe file and executing it.
    Could do this with a shell script or here (in the python script).

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.implementation_file.purity_percent"><code class="name flex">
<span>def <span class="ident">purity_percent</span></span>(<span>fragment_isotope)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary.</p>
<p>Retrieve the overall purity for the fragment you are studying after
passinng through the FP_PIN (focal plane Particle in) detector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def purity_percent(fragment_isotope):
    &#34;&#34;&#34;Summary.

    Retrieve the overall purity for the fragment you are studying after
     passinng through the FP_PIN (focal plane Particle in) detector.

    &#34;&#34;&#34;
    print(f&#34;Retrieving beam purity for {fragment_isotope}...&#34;)
    pag.moveTo(832, 83)  # run all nucleo buttom (red lightning bolt)
    pag.click()
    time.sleep(40)
    pag.moveTo(999, 77)  # x spatial distribution
    pag.click()
    pag.dragTo(1110, 629, .5)  # FP_PIN detector
    pag.click(interval=.5)
    time.sleep(4)
    pag.moveTo(14, 316)  # stats box
    pag.click()
    pag.press(&#34;enter&#34;)  # accept
    time.sleep(1)
    pag.moveTo(1609, 201)  # file save button
    pag.click()
    &#34;&#34;&#34;
        pag.moveTo(365,195) #drop down
        pag.click()
        #pag.press(&#34;d&#34;,presses=2,interval=1) #to save in desktop
        pag.press(&#34;d&#34;,interval=1) #to save in desktop
        pag.press(&#34;enter&#34;)
        &#34;&#34;&#34;
    pag.moveTo(389, 413)  # file save text box
    pag.click()

    # desktop comes from top of the sript.
    filename = str(desktop) + r&#34;\pps_data.txt&#34;
    print(f&#34;The file is being saved at the following location: {filename}&#34;)
    pag.write(filename)

    # pag.write(&#34;pps_junk.txt&#34;)
    pag.press(&#34;enter&#34;)  # save file
    pag.press(&#34;left&#34;)
    pag.press(&#34;enter&#34;)  # this &#34;enter&#34; saves the file to desktop
    pag.moveTo(1682, 122)
    pag.click()
    pag.moveTo(1877, 13)
    pag.click()
    df = pd.read_csv(filename, error_bad_lines=False)
    # df =
    # pd.read_csv(&#34;C:\\Users\Owner\Desktop\pps_junk.txt&#34;,error_bad_lines=False)
    # #path to temporary file. NEED TO UPDATE
    #print(f&#34;Size of data frame is {df.size}.&#34;)
    _string = df.iloc[5, 0]  # get the pps for isotope in question
    _string = _string.split()
    isotope_fragment = _string[13]  # grab pps value
    total = 0.
    for i in range(5, df.size):
        string = df.iloc[i, 0]
        string = string.split()
        # to get it to correct scientific notation
        val = float(float(string[13]))
        total = total + val
    print(f&#34;The total amount of pps is {total}.&#34;)
    frag_val = float(float(isotope_fragment))
    print(
        f&#34;Percent of {fragment_isotope} in beam is {(float(float(frag_val))/total)*100.} %&#34;)
    percent = (float(float(frag_val)) / total) * 100.
    return percent</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.implementation_file.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the thickness to a text file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save():
    &#34;&#34;&#34;Save the thickness to a text file.&#34;&#34;&#34;
    with open(&#34;thickness.txt&#34;, &#34;w&#34;) as file:
        file.write(json.dumps(isotope_info))
    file.close()</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.implementation_file.set_FP_slits"><code class="name flex">
<span>def <span class="ident">set_FP_slits</span></span>(<span>slit_width)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary.</p>
<p>Sets the the distance of the focal plane slits. The slit_width is passed in as the argument.
Important to set the appropriate Focal Plane (FP) slits to be able to achieve a compromise
between the purity of the beam and yield.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_FP_slits(slit_width):
    &#34;&#34;&#34;Summary.

    Sets the the distance of the focal plane slits. The slit_width is passed in as the argument.
    Important to set the appropriate Focal Plane (FP) slits to be able to achieve a compromise
    between the purity of the beam and yield.

    &#34;&#34;&#34;
    print(&#34;Setting FP_Slits...&#34;)
    pag.moveTo(65, 684)  # move to slit button
    pag.click()
    pag.moveTo(764, 231)
    pag.click()
    pag.write(str(slit_width))
    pag.moveTo(238, 447)
    pag.click()
    pag.moveTo(71, 744)
    pag.click()</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.implementation_file.set_I2_wedge"><code class="name flex">
<span>def <span class="ident">set_I2_wedge</span></span>(<span>wedge_thickness)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary.</p>
<p>Use to set the thickness of the wedge at the second image plane 'I2'.
Important due to the magnets adjusting to the wedge with the appropriate
Brho value to maximize the transmission of the fragment
you are interested and reduce the amount of contaminants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_I2_wedge(wedge_thickness):
    &#34;&#34;&#34;Summary.

    Use to set the thickness of the wedge at the second image plane &#39;I2&#39;.
    Important due to the magnets adjusting to the wedge with the appropriate
    Brho value to maximize the transmission of the fragment
    you are interested and reduce the amount of contaminants.

    &#34;&#34;&#34;
    print(&#34;Setting I2_wedge...&#34;)
    pag.moveTo(60, 461)  # move to wedge button
    pag.click(interval=1)
    pag.write(str(wedge_thickness))
    pag.moveTo(926, 223)  # set spectrometer after block
    pag.click(interval=1)
    time.sleep(2)
    pag.moveTo(397, 398)  # select wedge profile
    pag.click(interval=1)
    pag.moveTo(881, 394)  # move to calculate angle
    pag.click()
    time.sleep(10)  # wait
    pag.moveTo(371, 479)  # fit achromatic angle from LISE calc.
    pag.click()
    pag.moveTo(308, 530)  # select the angle and copy
    pag.doubleClick()
    pc.copy(&#34;&#34;)
    time.sleep(2)
    # done twice due to bug in not properly copying. This fixes that bug.
    pag.hotkey(&#39;ctrl&#39;, &#39;c&#39;)
    time.sleep(1)
    pag.hotkey(&#39;ctrl&#39;, &#39;c&#39;)
    angle = pc.paste()
    pag.moveTo(168, 622)  # ok button
    pag.click()
    pag.moveTo(152, 535)
    pag.click()
    print(f&#34;The angle for the wedge is -{angle}.&#34;)
    return str(angle)</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.implementation_file.set_fragment"><code class="name flex">
<span>def <span class="ident">set_fragment</span></span>(<span>fragment, A)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary.</p>
<p>Set the fragment you are interested in studying. Pass in the name of the
fragment and mass number A.
This is handled automatically in the loop, no need to set it
yourself (besided debugging/upgrading reasons).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fragment(fragment, A):
    &#34;&#34;&#34;Summary.

    Set the fragment you are interested in studying. Pass in the name of the
    fragment and mass number A.
    This is handled automatically in the loop, no need to set it
    yourself (besided debugging/upgrading reasons).

    &#34;&#34;&#34;
    print(&#34;Setting fragment...&#34;)
    pag.moveTo(20, 170)  # projectile button
    pag.click()
    pag.moveTo(250, 463)  # element text box
    pag.doubleClick()
    # pag.press(&#34;delete&#34;)
    pag.write(str(A))
    pag.moveTo(309, 470)  # element text box
    pag.doubleClick()
    # pag.press(&#34;delete&#34;)
    pag.write(fragment)
    pag.moveTo(624, 521)  # energy
    pag.click()
    time.sleep(1)</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.implementation_file.set_projectile"><code class="name flex">
<span>def <span class="ident">set_projectile</span></span>(<span>projectile_name, energy, intensity, A)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary.</p>
<p>Set the incoming projectile in LISE++ based on the projectiles name, energy,
intensity, and atomic number (mass) A.
Passed in to the arguments in the following order: projectile_name, energy,
intensity, A.</p>
<p>Current list of isotopes that can be used for target can be found at:
<a href="https://nscl.msu.edu/users/beams.html">https://nscl.msu.edu/users/beams.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_projectile(projectile_name, energy, intensity, A):
    &#34;&#34;&#34;Summary.

    Set the incoming projectile in LISE++ based on the projectiles name, energy,
    intensity, and atomic number (mass) A.
    Passed in to the arguments in the following order: projectile_name, energy,
    intensity, A.

    Current list of isotopes that can be used for target can be found at:
    https://nscl.msu.edu/users/beams.html

    &#34;&#34;&#34;
    print(&#34;Setting projectile...&#34;)
    pag.moveTo(16, 124)  # projectile button
    pag.click(interval=.5)
    pag.moveTo(262, 213)  # element text box
    pag.doubleClick()
    pag.write(projectile_name)
    pag.moveTo(231, 211)  # The mass number box
    pag.doubleClick()
    pag.write(str(A))
    pag.moveTo(519, 213)  # energy
    pag.doubleClick()
    pag.write(str(energy))
    pag.moveTo(523, 421)  # beam intensity
    pag.doubleClick()
    pag.write(str(intensity))
    pag.moveTo(269, 445)
    pag.click(interval=.5)
    time.sleep(1)</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.implementation_file.show_pixels"><code class="name flex">
<span>def <span class="ident">show_pixels</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the pixel location on your screen as you move your cursor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_pixels():
    &#34;&#34;&#34;Show the pixel location on your screen as you move your cursor.&#34;&#34;&#34;
    print(&#39;Press Ctrl-C to quit.&#39;)
    try:
        while True:
            x, y = pag.position()
            positionStr = &#39;X: &#39; + str(x).rjust(4) + &#39; Y: &#39; + str(y).rjust(4)
            print(positionStr, end=&#39;&#39;)
            print(&#39;\b&#39; * len(positionStr), end=&#39;&#39;, flush=True)
    except KeyboardInterrupt:
        print(&#39;\n&#39;)</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.implementation_file.slice_array"><code class="name flex">
<span>def <span class="ident">slice_array</span></span>(<span>arr, start)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary.</p>
<p>To "slice" an array of dictionaries and return sliced array.</p>
<p>Function to slice an array. Pass in the array and where you want to begin slicing from.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_array(arr, start):
    &#34;&#34;&#34;Summary.

    To &#34;slice&#34; an array of dictionaries and return sliced array.

    Function to slice an array. Pass in the array and where you want to begin slicing from.
    &#34;&#34;&#34;
    new_array = []
    index = 0
    for i, dic in enumerate(arr):
        # grab individual dictionary in that specific array index
        temp_dic = arr[i]
        if temp_dic[&#34;isotope&#34;] == str(
                start):  # if starting isotope is found, save the index location
            index = i
            break
    for t in range(index, len(arr)):
        new_array.append(arr[t])
    return new_array  # return a sliced array containing dictionaries from starting isotope</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.implementation_file.tune_spectrometer"><code class="name flex">
<span>def <span class="ident">tune_spectrometer</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Tune the overall spectrometer to optimize transmission. Done by LISE++.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tune_spectrometer():
    &#34;&#34;&#34;Tune the overall spectrometer to optimize transmission. Done by LISE++.&#34;&#34;&#34;
    print(&#34;Tuning spectrometer...&#34;)
    pag.moveTo(335, 78)
    pag.click()
    time.sleep(1)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nuclear_gamma_tracker" href="index.html">nuclear_gamma_tracker</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="nuclear_gamma_tracker.implementation_file.beam_info" href="#nuclear_gamma_tracker.implementation_file.beam_info">beam_info</a></code></li>
<li><code><a title="nuclear_gamma_tracker.implementation_file.pixel_locations" href="#nuclear_gamma_tracker.implementation_file.pixel_locations">pixel_locations</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="nuclear_gamma_tracker.implementation_file.FP_slit_X_transmission_percent" href="#nuclear_gamma_tracker.implementation_file.FP_slit_X_transmission_percent">FP_slit_X_transmission_percent</a></code></li>
<li><code><a title="nuclear_gamma_tracker.implementation_file.get_intensity" href="#nuclear_gamma_tracker.implementation_file.get_intensity">get_intensity</a></code></li>
<li><code><a title="nuclear_gamma_tracker.implementation_file.get_thickness" href="#nuclear_gamma_tracker.implementation_file.get_thickness">get_thickness</a></code></li>
<li><code><a title="nuclear_gamma_tracker.implementation_file.isotope_loop" href="#nuclear_gamma_tracker.implementation_file.isotope_loop">isotope_loop</a></code></li>
<li><code><a title="nuclear_gamma_tracker.implementation_file.isotope_tuning_values" href="#nuclear_gamma_tracker.implementation_file.isotope_tuning_values">isotope_tuning_values</a></code></li>
<li><code><a title="nuclear_gamma_tracker.implementation_file.notes" href="#nuclear_gamma_tracker.implementation_file.notes">notes</a></code></li>
<li><code><a title="nuclear_gamma_tracker.implementation_file.purity_percent" href="#nuclear_gamma_tracker.implementation_file.purity_percent">purity_percent</a></code></li>
<li><code><a title="nuclear_gamma_tracker.implementation_file.save" href="#nuclear_gamma_tracker.implementation_file.save">save</a></code></li>
<li><code><a title="nuclear_gamma_tracker.implementation_file.set_FP_slits" href="#nuclear_gamma_tracker.implementation_file.set_FP_slits">set_FP_slits</a></code></li>
<li><code><a title="nuclear_gamma_tracker.implementation_file.set_I2_wedge" href="#nuclear_gamma_tracker.implementation_file.set_I2_wedge">set_I2_wedge</a></code></li>
<li><code><a title="nuclear_gamma_tracker.implementation_file.set_fragment" href="#nuclear_gamma_tracker.implementation_file.set_fragment">set_fragment</a></code></li>
<li><code><a title="nuclear_gamma_tracker.implementation_file.set_projectile" href="#nuclear_gamma_tracker.implementation_file.set_projectile">set_projectile</a></code></li>
<li><code><a title="nuclear_gamma_tracker.implementation_file.show_pixels" href="#nuclear_gamma_tracker.implementation_file.show_pixels">show_pixels</a></code></li>
<li><code><a title="nuclear_gamma_tracker.implementation_file.slice_array" href="#nuclear_gamma_tracker.implementation_file.slice_array">slice_array</a></code></li>
<li><code><a title="nuclear_gamma_tracker.implementation_file.tune_spectrometer" href="#nuclear_gamma_tracker.implementation_file.tune_spectrometer">tune_spectrometer</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>