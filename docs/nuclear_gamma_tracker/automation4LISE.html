<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>nuclear_gamma_tracker.automation4LISE API documentation</title>
<meta name="description" content="Summary â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nuclear_gamma_tracker.automation4LISE</code></h1>
</header>
<section id="section-intro">
<p>Summary</p>
<p>Module to control automation in LISE++ with NSCL configuration file.
The implementation of the FRIB configuration file is yet to be developed.</p>
<p>Purpose: To retrive particular parameters from LISE++ such as beam intensity,
beam purity, wedge thickness, wedge angle, momentum acceptance, focal
plane slit width, and Image 2 slit width. </p>
<p>All beam data comes from NSCL website: <a href="https://nscl.msu.edu/users/beams.html">https://nscl.msu.edu/users/beams.html</a></p>
<p>Python version: 3.7.1 </p>
<p>Currently, this is set up to only works with a Windows OS.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Summary

Module to control automation in LISE++ with NSCL configuration file.
The implementation of the FRIB configuration file is yet to be developed.

Purpose: To retrive particular parameters from LISE++ such as beam intensity,
beam purity, wedge thickness, wedge angle, momentum acceptance, focal
plane slit width, and Image 2 slit width. 

All beam data comes from NSCL website: https://nscl.msu.edu/users/beams.html

Python version: 3.7.1 

Currently, this is set up to only works with a Windows OS.

&#34;&#34;&#34;

import time
import pyautogui as pag  
import matplotlib.pyplot as plt
import pyperclip as pc 
import pandas as pd 
import numpy as np
import csv
import os 
import platform 


pag.PAUSE=1
pag.FAILSAFE=True
width, height = pag.size()
print(f&#34;Scren size is: {width},{height}&#34;)



&#34;&#34;&#34;
pixel locations for each isotope based on my screen (Resolution: 1920x1080)

Note: This can be improved to contain images of the isotope that appears on the screen. Doing this rids the dependence 
on one&#39;s screen resolution and local pixel coordinates.

&#34;&#34;&#34;
pixel_locations = { &#34;Mg_32&#34;:{&#34;x&#34;:1121,&#34;y&#34;:626},&#34;Mg_33&#34;:{&#34;x&#34;:1116,&#34;y&#34;:626},\
&#34;Mg_34&#34;:{&#34;x&#34;:1116,&#34;y&#34;:626} ,&#34;Mg_35&#34;:{&#34;x&#34;:1116,&#34;y&#34;:626},&#34;Mg_36&#34;:{&#34;x&#34;:1136,&#34;y&#34;:626},\
&#34;Mg_37&#34;:{&#34;x&#34;:1116,&#34;y&#34;:626},&#34;Mg_38&#34;:{&#34;x&#34;:1116,&#34;y&#34;:626},&#34;Mg_40&#34;:{&#34;x&#34;:1106,&#34;y&#34;:626}}


&#34;&#34;&#34;
An array of dictionaries (c++ maps). &#34;data&#34; is the key for the corresponding isotope and its value is an array of data. 
Using zeros as place holders for intialization. 

&#34;&#34;&#34;
#array of maps, data is the key to the map, replace the zero&#39;s with arrays of data
#isotppe is one of the keys, data is the other key for that map with their corresponding values
isotope_info = [ \
{&#34;isotope&#34;:&#34;Mg_32&#34;, &#34;data&#34;:0.0}, \
{&#34;isotope&#34;:&#34;Mg_33&#34;,&#34;data&#34;:0.0},  \
{&#34;isotope&#34;:&#34;Mg_34&#34;,&#34;data&#34;:0.0},  \
{&#34;isotope&#34;:&#34;Mg_35&#34;,&#34;data&#34;:0.0},  \
{&#34;isotope&#34;:&#34;Mg_36&#34;,&#34;data&#34;:0.0},  \
{&#34;isotope&#34;:&#34;Mg_37&#34;,&#34;data&#34;:0.0},  \
{&#34;isotope&#34;:&#34;Mg_38&#34;,&#34;data&#34;:0.0},  \
{&#34;isotope&#34;:&#34;Mg_40&#34;,&#34;data&#34;:0.0}   ]

#dictionary of dictionary
beam_info = {&#34;O_16&#34;: {&#34;Energy&#34;:150,&#34;Intensity&#34;:175}, &#34;O_18&#34;:{&#34;Energy&#34;:120,&#34;Intensity&#34;:150},\
&#34;Ne_20&#34;: {&#34;Energy&#34;:170,&#34;Intensity&#34;:80},&#34;Ne_22&#34;:{&#34;Energy&#34;:150,&#34;Intensity&#34;:100},  \
&#34;Mg_24&#34;:{&#34;Energy&#34;:170,&#34;Intensity&#34;:60},&#34;Si_28&#34;:{&#34;Energy&#34;:160,&#34;Intensity&#34;:10},   \
&#34;S_32&#34; : {&#34;Energy&#34;:150,&#34;Intensity&#34;:60}, &#34;Ar_36&#34;:{&#34;Energy&#34;:150,&#34;Intensity&#34;:75}, \
&#34;Ca_40&#34;:{&#34;Energy&#34;:140,&#34;Intensity&#34;:50}, &#34;Ca_48&#34;:{&#34;Energy&#34;:90,&#34;Intensity&#34;:15},   \
&#34;Ca_48&#34;:{&#34;Energy&#34;:140,&#34;Intensity&#34;:80}, &#34;Ni_58&#34;:{&#34;Energy&#34;:160,&#34;Intensity&#34;:20},\
&#34;Ni_64&#34;:{&#34;Energy&#34;:140,&#34;Intensity&#34;:7}, &#34;Ge_76&#34;:{&#34;Energy&#34;:130,&#34;Intensity&#34;:25}
}


#Didn&#39;t include the rest of the beam list, intensity was too low to be significant.
&#34;&#34;&#34;
,   \
&#34;Se_82&#34;:{&#34;Energy&#34;:140,&#34;Intensity&#34;:45}, &#34;Kr_78&#34;:{&#34;Energy&#34;:150,&#34;Intensity&#34;:25},  \
&#34;Kr_86&#34;:{&#34;Energy&#34;:100,&#34;Intensity&#34;:15},&#34;Zr_96&#34;:{&#34;Energy&#34;:120,&#34;Intensity&#34;:3},    \
&#34;Mo_92&#34;:{&#34;Energy&#34;:140,&#34;Intensity&#34;:10}, &#34;Sn_112&#34;:{&#34;Energy&#34;:120,&#34;Intensity&#34;:4},  \
&#34;Sn_124&#34;:{&#34;Energy&#34;:120,&#34;Intensity&#34;:1.5} #incomplete but enough for our purposes
 } 

&#34;&#34;&#34;


def _isotope_start():
        &#34;&#34;&#34;Summary

        Function to collect the isotope you want to start with. Have to enter the isotpes as &#39;Mg_32&#39;, for example.
        Currently, can only select between isotopes Mg_32 - Mg_40.
        
        &#34;&#34;&#34;
        isotope_start= input(&#34;Which isotope would you like to start with? (Enter as &#39;Mg_32&#39; for example.): &#34;)
        print(f&#34;Starting with {isotope_start}...&#34;)
        return isotope_start

def _isotope_end():
        &#34;&#34;&#34;Summary: 

        Function to collect the isotope you want to end with. Have to enter the isotpes as &#39;Mg_32&#39;, for example. 
        Currenlty, the furthest you can go is Mg_40.
        
        &#34;&#34;&#34;
        isotope_end= input(&#34;Which isotope would you like to end with? (Enter as &#39;Mg_36&#39; for example.): &#34;)
        print(f&#34;Ending with {isotope_end}...&#34;)
        return isotope_end

def notes():
        &#34;&#34;&#34;General Notes: 

        If program is not open, look for the program image on deskotp, and click on it. 

        Note: Could improve by having it go directly to the LISE++.exe file and executing it. Could do this 
        with a shell script or here (in the python script).

        &#34;&#34;&#34;

def set_projectile(projectile_name,energy,intensity,A):
        &#34;&#34;&#34;Summary

        Set the incoming projectile in LISE++ based on the projectiles name, energy, intensity, and atomic number (mass) A.
        Passed in to the arguments in the following order: projectile_name, energy, intensity, A.

        Current list of isotopes that can be used for target can be found at:
        https://nscl.msu.edu/users/beams.html

        &#34;&#34;&#34;
        print(&#34;Setting projectile...&#34;)
        pag.moveTo(16,124) #projectile button 
        pag.click()
        pag.moveTo(262,213) #element text box
        pag.doubleClick()
        pag.write(projectile_name)
        pag.moveTo(231,211) # The mass number box
        pag.doubleClick()
        pag.write(str(A))
        pag.moveTo(519,213) #energy
        pag.doubleClick()
        pag.write(str(energy))
        pag.moveTo(523,421) #beam intensity 
        pag.doubleClick()
        pag.write(str(intensity))
        pag.moveTo(269,445)
        pag.click()
        time.sleep(1)

#to set the Focal Plane (FP) slits
def set_FP_slits(slit_width):
        &#34;&#34;&#34;Summary
        
        Sets the the distance of the focal plane slits. The slit_width is passed in as the argument. 
        Important to set the appropriate Focal Plane (FP) slits to be able to achieve a compromise
        between the purity of the beam and yield.

        &#34;&#34;&#34;
        print(&#34;Setting FP_Slits...&#34;)
        pag.moveTo(65,684) #move to slit button 
        pag.click()
        pag.moveTo(764,231)
        pag.click()
        pag.write(str(slit_width))
        pag.moveTo(238,447)
        pag.click()
        pag.moveTo(71,744)
        pag.click()

#to set the wedge thickness 
def set_I2_wedge(wedge_thickness):
        &#34;&#34;&#34;Summary

        Use to set the thickness of the wedge at the second image plane &#39;I2&#39;. Important due to the magnets 
        adjusting to the wedge with the appropriate Brho value to maximize the transmission of the fragment 
        you are interested and reduce the amount of contaminants.

        &#34;&#34;&#34;
        print(&#34;Setting I2_wedge...&#34;)
        pag.moveTo(60,461) #move to wedge button 
        pag.click()
        pag.write(str(wedge_thickness))
        pag.moveTo(926,223) #set spectrometer after block
        pag.click()
        time.sleep(2)
        pag.moveTo(397,398) #select wedge profile
        pag.click()
        pag.moveTo(881,394) #move to calculate angle 
        pag.click()
        time.sleep(10) #wait 
        pag.moveTo(371,479) #fit achromatic angle from LISE calc.
        pag.click()
        pag.moveTo(308,530) #select the angle and copy 
        pag.doubleClick()
        pc.copy(&#34;&#34;)
        time.sleep(2)
        pag.hotkey(&#39;ctrl&#39;,&#39;c&#39;) #done twice due to bug in not properly copying. This fixes that bug.
        time.sleep(1)
        pag.hotkey(&#39;ctrl&#39;,&#39;c&#39;)
        angle = pc.paste()
        pag.moveTo(168,622) #ok button 
        pag.click()
        pag.moveTo(152,535)
        pag.click()
        print(f&#34;The angle for the wedge is -{angle}.&#34;)
        return str(angle)

def tune_spectrometer():
        &#34;&#34;&#34;Tune the overall spectrometer to optimize transmission. Done by LISE++.&#34;&#34;&#34;
        print(&#34;Tuning spectrometer...&#34;)
        pag.moveTo(335,78)
        pag.click()
        time.sleep(1)

def set_fragment(fragment,A):
        &#34;&#34;&#34;Summary

        Set the fragment you are interested in studying. Pass in the name of the fragment and mass number A.
        This is handled automatically in the loop, no need to set it yourself (besided debugging/upgrading reasons).

        &#34;&#34;&#34;
        print(&#34;Setting fragment...&#34;)
        pag.moveTo(20,170) #projectile button 
        pag.click()
        pag.moveTo(250,463) #element text box
        pag.doubleClick()
        #pag.press(&#34;delete&#34;)
        pag.write(str(A))
        pag.moveTo(309,470) #element text box
        pag.doubleClick()
        #pag.press(&#34;delete&#34;)
        pag.write(fragment)
        pag.moveTo(624,521) #energy
        pag.click()
        time.sleep(1)

#to retrive the thickness 
def get_thickness():
        &#34;&#34;&#34;To retrive the thickness of the target after optmizing. Optimizing is done by LISE++.&#34;&#34;&#34;
        target_thickness = 0
        pc.copy(&#34;&#34;) #clear clipboard
        print(&#34;Retrieving thickness...&#34;)
        pag.moveTo(453,38) #calculations 
        pag.click()
        pag.dragTo(504, 151,.5) #Optimum target
        time.sleep(.6)
        pag.moveTo(381,485) # first ok 
        pag.click()
        pag.moveTo(326,655) # second ok 
        pag.click()
        time.sleep(20)
        pag.moveTo(260,451) #load thickness
        pag.click()
        pag.moveTo(1629,160) #exit first plot
        pag.click()
        pag.moveTo(1600,93) #exit second plot
        pag.click()
        pag.moveTo(24,196) #target button 
        pag.click()
        pag.moveTo(477,286) #box containing info 
        time.sleep(1)
        pag.doubleClick()
        time.sleep(1)
        pag.hotkey(&#39;ctrl&#39; , &#39;c&#39;) #copy 
        time.sleep(1)
        target_thickness = pc.paste() #paste it to a variable 
        print(f&#34;Thickness is {target_thickness} microns&#34;)
        &#34;&#34;&#34;
        for i,m in enumerate(isotope_info):
                if isotope_info[i][&#34;isotope&#34;] == isotope_select:
                        isotope_info[i][&#34;thickness&#34;] = s
                        iso_name, iso_t = isotope_info[i][&#34;isotope&#34;] , isotope_info[i][&#34;thickness&#34;]
                        print(iso_name,iso_t)
        &#34;&#34;&#34;
        pag.moveTo(456,459) #ok button to close
        pag.click()
        return target_thickness 

#to retrive intensity
def get_intensity(isotope,beam_element,beam_mass):
        &#34;&#34;&#34;Summary

        Retrieve the intensity based on the isotope you are interested in, the beam isotope (element) you are using, and the mass number 
        for the beam element.
        &#34;&#34;&#34;
        flag = False
        print(isotope)
        #get pixel location of isotope on screen
        print(&#34;Retrieving intensity...&#34;)
        x = pixel_locations[isotope][&#34;x&#34;]
        y = pixel_locations[isotope][&#34;y&#34;]
        #print(x,y)
        pag.position()
        pag.moveTo(x,y)
        pag.click(button=&#34;right&#34;)
        pag.moveTo(1483,417) #File save button 
        pag.click()

        &#34;&#34;&#34;
        pag.moveTo(532,121) #drop down 
        pag.click()
        #pag.press(&#34;d&#34;,presses=2,interval=1) #to save in desktop
        pag.press(&#34;d&#34;,interval=1) #to save in desktop
        pag.press(&#34;enter&#34;)
        &#34;&#34;&#34;
        pag.moveTo(531,339) #file save text box
        pag.click()
        filename = str(desktop) + &#34;\data.txt&#34; #desktop comes from top of the sript.
        print(f&#34;The file is being saved at the following location: {filename}&#34;)
        pag.write(filename)
        #pag.write(&#34;junk.txt&#34;)
        pag.press(&#34;enter&#34;)
        pag.press(&#34;left&#34;)
        pag.press(&#34;enter&#34;) #this &#34;enter&#34; saves the file to desktop
        pag.moveTo(1563,44)
        pag.click()
        df = pd.read_csv(filename)
        #df = pd.read_csv(&#34;C:\\Users\Owner\Desktop\junk.txt&#34;) #path to temporary file. NEED TO UPDATE 
        #print(df)
        intensity_check=df.iloc[0,0]  #location of the intensity in the data frame. Usually included an extra line if it is zero
        intensity_check = intensity_check.split()
        print(intensity_check)
        if len(intensity_check) == 6:
                if intensity_check[5] == &#34;0!&#34;:
                        print(&#34;TRANSMISSION IS 0.0% WITH THIS PROJECTILE &#34;)
                        flag = True
                        return 0,flag 
        else: 
                _intensity=df.iloc[6,0] #location of the intensity in the data frame 
                _intensity=_intensity.split()
                print(f&#34;The intensity for {isotope} with {beam_element} {beam_mass} is {_intensity[4]}.&#34;) #intensity value
                return _intensity[4],flag

#retrieve the transmission in X-space 
def FP_slit_X_transmission_percent():
        &#34;&#34;&#34;Summary

        Retrieve the transmission percent in the x direction at the focal plane. Incoming beam looks &#39;Gaussian&#39; but 
        there is very litter dispersion in y direction.
        &#34;&#34;&#34;
        #NEED TO WORK ON THIS
        print(&#34;Getting FP_Slits X space transmission...&#34;)
        filename = str(desktop) + &#34;\data.txt&#34; #desktop comes from top of the sript.
        df = pd.read_csv(filename)
        FP_x_space_transmission = df.iloc[39,0] #location in the .csv file
        FP_x_space_transmission = FP_x_space_transmission.split()
        #print(FP_x_space_transmission[4])
        return FP_x_space_transmission[4] #percent value 

def purity_percent(fragment_isotope):
        &#34;&#34;&#34;Summary
        
        Retrieve the overall purity for the fragment you are studying after passinng through the FP_PIN (focal plane Particle in) detector.
        
        &#34;&#34;&#34;
        print(f&#34;Retrieving beam purity for {fragment_isotope}...&#34;)
        pag.moveTo(832,83) #run all nucleo buttom (red lightning bolt)
        pag.click()
        time.sleep(40)
        pag.moveTo(999,77) #x spatial distribution 
        pag.click()
        pag.dragTo(1110, 629,.5) #FP_PIN detector
        pag.click(interval=.5) 
        time.sleep(4)
        pag.moveTo(14,316) #stats box
        pag.click()
        pag.press(&#34;enter&#34;) #accept
        time.sleep(1)
        pag.moveTo(1609,201) #file save button
        pag.click()
        &#34;&#34;&#34;
        pag.moveTo(365,195) #drop down 
        pag.click()
        #pag.press(&#34;d&#34;,presses=2,interval=1) #to save in desktop
        pag.press(&#34;d&#34;,interval=1) #to save in desktop
        pag.press(&#34;enter&#34;)
        &#34;&#34;&#34;
        pag.moveTo(389,413) #file save text box
        pag.click()

        filename = str(desktop) + &#34;\pps_data.txt&#34; #desktop comes from top of the sript.
        print(f&#34;The file is being saved at the following location: {filename}&#34;)
        pag.write(filename)

        #pag.write(&#34;pps_junk.txt&#34;)
        pag.press(&#34;enter&#34;) #save file
        pag.press(&#34;left&#34;)
        pag.press(&#34;enter&#34;) #this &#34;enter&#34; saves the file to desktop
        pag.moveTo(1682,122)
        pag.click()
        pag.moveTo(1877,13)
        pag.click()
        df = pd.read_csv(filename,error_bad_lines=False)
        #df = pd.read_csv(&#34;C:\\Users\Owner\Desktop\pps_junk.txt&#34;,error_bad_lines=False) #path to temporary file. NEED TO UPDATE
        print(f&#34;Size of data frame is {df.size}.&#34;)
        _string = df.iloc[5,0] #get the pps for isotope in question
        _string = _string.split()
        isotope_fragment = _string[13] #grab pps value
        total = 0.
        for i in range(5,df.size): 
                string = df.iloc[i,0]
                string = string.split()
                val = float(float(string[13])) #to get it to correct scientific notation
                total = total + val
        print(f&#34;The total amount of pps is {total}.&#34;)
        frag_val = float(float(isotope_fragment))
        print(f&#34;Percent of {fragment_isotope} in beam is {(float(float(frag_val))/total)*100.} %&#34;)
        percent =(float(float(frag_val))/total)*100.
        return percent

def isotope_loop():
        &#34;&#34;&#34;Use to find the best beam for each isotope. However, it has already been determined that the best beam is Ca 48.&#34;&#34;&#34;
        beam_data = []
        start = time.time()
        df = pd.DataFrame(None) #create our data frame
        for i,dic in enumerate(isotope_info): #loop for fragments
                df = df[0:0]
                df = pd.DataFrame(columns=[&#34;Beam element&#34;,&#34;A (u)&#34;,&#34;Beam energy (MeV/u)&#34;,&#34;Beam Intensity (pnA)&#34;,&#34;Target thickness (microns)&#34;,&#34;Fragment Intensity (pnA)&#34;])
                data = [] 
                iso=dic[&#39;isotope&#39;].replace(&#34;_&#34;,&#34; &#34;) #get rid of the underscore in the isotope name
                print(f&#34;You are looking at the {iso} isotope.&#34;)  #returns the name of the isotope
                iso = iso.split()
                set_fragment(iso[0],iso[1]) #fragment name, mass number
                for i,beam_element in enumerate(beam_info): #now loop for all the provided beams
                        print(f&#34;You are using {beam_element} as your primary beam at {beam_info[beam_element][&#39;Energy&#39;]} MeV/u with {beam_info[beam_element][&#39;Intensity&#39;]} pnA.&#34;)
                        beam_energy= beam_info[beam_element][&#34;Energy&#34;]
                        beam_intensity=beam_info[beam_element][&#34;Intensity&#34;]
                        beam_element=beam_element.replace(&#34;_&#34;,&#34; &#34;)
                        beam_element=beam_element.split()
                        if beam_element[1] &lt;= iso[1]:
                                print(f&#34;Skipping {beam_element[0]} {beam_element[1]}. Not greater than {iso[1]} nucleons.&#34;)
                                continue
                        #                               name, energy, intensity, mass number A
                        set_projectile(beam_element[0],beam_energy,beam_intensity,beam_element[1])
                        thickness = get_thickness() #thickness with that particular beam for a particular fragment 
                        tune_spectrometer()
                        frag_intensity,flag = get_intensity(dic[&#39;isotope&#39;],beam_element[0],beam_element[1]) #pass the isotope name to get intensity and save it to the map with the frag info
                        if flag == True:
                                continue
                        print(f&#34;Data being appended in the following format -&gt; beam element, A,beam energy, beam intensity, thickness, fragment intensity: {beam_element[0]},{beam_element[1]} ,{beam_energy},{beam_intensity},{thickness}, {frag_intensity}&#34;)
                        df.loc[i] = [beam_element[0],beam_element[1],beam_energy,beam_intensity,thickness,frag_intensity]
                        print(df)
                print(f&#34;DATA FRAME FOR {iso[0]} {iso[1]} ISOTOPE.&#34;)
                print(df)
                df.to_csv(f&#34;{iso[0]}_{iso[1]}_data_LISE++.csv&#34;)
                print(f&#34;File saved as: {iso[0]}_{iso[1]}_data_LISE++.csv&#34;)
        end = time.time()
        print(f&#34;It took {end-start} to run everything.&#34;)


def slice_array(arr,start):
        &#34;&#34;&#34;Summary

        To &#34;slice&#34; an array of dictionaries and return sliced array.

        Function to slice an array. Pass in the array and where you want to beginn slicing from. 
        &#34;&#34;&#34;
        new_array = []
        index =0
        for i,dic in enumerate(arr):
                temp_dic = arr[i] #grab individual dictionary in that specific array index
                if temp_dic[&#34;isotope&#34;] == str(start): #if starting isotope is found, save the index location
                        index =i
                        break
        for t in range(index,len(arr)):
                new_array.append(arr[t])
        return new_array #return a sliced array containing dictionaries from starting isotope

def isotope_tuning_values(FP_slit_width,isotope_start,isotope_end,wedge_range):
        &#34;&#34;&#34;To find the best configuration using a Ca 48 beam.&#34;&#34;&#34;
        set_projectile(&#34;Ca&#34;,140,80,48) #set the beam here with element name, energy, intensity, atomic number 
        start = time.time()
        set_FP_slits(FP_slit_width)
        #if bool_value == True: #if you want to start from  a particular isotope
        new_isotope_dic = slice_array(isotope_info,isotope_start)
        for i,dic in enumerate(new_isotope_dic): #loop for each fragment
                df = pd.DataFrame(None) #create our data frame
                df = pd.DataFrame(columns=[&#34;I_2 slit width (mm) &#34;,&#34;Intensity (pps) &#34;,&#34;Target thickness (microns) &#34;,&#34;Horizontal FP Slit width (mm)&#34;,&#34;Purity transmission % &#34;,&#34;Mom. Accpetance % &#34;, &#34;Wedge thickness (microns) &#34;,&#34;wedge angle (mrad)&#34;])
                iso=dic[&#39;isotope&#39;].replace(&#34;_&#34;,&#34; &#34;) #get rid of the underscore in the isotope name
                print(f&#34;You are looking at the {iso} isotope.&#34;)  #returns the name of the isotope
                iso = iso.split()
                set_fragment(iso[0],iso[1])
                #wedge_thickness = 2300 #wedge thickness to start with 
                for count,wedge_thickness in enumerate(wedge_range): #loop over each wedge thickness
                        print(f&#34;Currently using {wedge_thickness} microns for {iso[0]} {iso[1]}&#34;)
                        tune_spectrometer()
                        preliminary_wedge_angle = set_I2_wedge(str(wedge_thickness))    # There is a dependence between target and wedge. Doing it twice gives best results 
                        tune_spectrometer()
                        preliminary_target_thickness = get_thickness()
                        tune_spectrometer()
                        wedge_angle = set_I2_wedge(str(wedge_thickness))
                        wedge_angle = &#34;-&#34; + wedge_angle                                 
                        tune_spectrometer()
                        target_thickness = get_thickness()
                        tune_spectrometer()
                        frag_intensity,flag = get_intensity(dic[&#39;isotope&#39;],&#34;Ca&#34;,48) #pass the isotope name to get intensity and save it to the map with the frag info
                        if flag == True: #if we have zero transmission, skip that wedge thickness
                                continue
                        #FP_x_space_transmission = FP_slit_X_transmission_percent()
                        _purity_percent = purity_percent(iso[0] + iso[1]) #pass in the name of the fragment isotope
                        print(f&#34;Purity is {_purity_percent}&#34;)
                        df.loc[count] = [29.5,frag_intensity,target_thickness,FP_slit_width,_purity_percent,1,wedge_thickness,wedge_angle] #harcode the 1% momentum acceptance
                        wedge_thickness=wedge_thickness+100
                        print(f&#34;Have gone through {count} iterations&#34;)
                        print(df)
                df.to_csv(f&#34;{iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)
                print(f&#34;File saved as: {iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)
                del df 
                if(dic[&#39;isotope&#39;] == isotope_end):
                        print(f&#34;YOU HAVE REACHED {isotope_end}!&#34;)
                        break
        end = time.time()
        print(f&#34;It took {(end-start)/60.0} minutes to run everything.&#34;)

def save():
        &#34;&#34;&#34;Save the thickness to a text file.&#34;&#34;&#34;
        with open(&#34;thickness.txt&#34;,&#34;w&#34;) as file:
                file.write(json.dumps(isotope_info))
        file.close()

#python 3 version 
def show_pixels():
        &#34;&#34;&#34;Show the pixel location on your screen as you move your cursor.&#34;&#34;&#34;
        print(&#39;Press Ctrl-C to quit.&#39;)
        try:
                while True:
                        x, y = pag.position()
                        positionStr = &#39;X: &#39; + str(x).rjust(4) + &#39; Y: &#39; + str(y).rjust(4)
                        print(positionStr, end=&#39;&#39;)
                        print(&#39;\b&#39; * len(positionStr), end=&#39;&#39;, flush=True)
        except KeyboardInterrupt:
                print(&#39;\n&#39;)
    
    
   
  </code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="nuclear_gamma_tracker.automation4LISE.beam_info"><code class="name">var <span class="ident">beam_info</span></code></dt>
<dd>
<div class="desc"><p>,
"Se_82":{"Energy":140,"Intensity":45}, "Kr_78":{"Energy":150,"Intensity":25},
"Kr_86":{"Energy":100,"Intensity":15},"Zr_96":{"Energy":120,"Intensity":3},
"Mo_92":{"Energy":140,"Intensity":10}, "Sn_112":{"Energy":120,"Intensity":4},
"Sn_124":{"Energy":120,"Intensity":1.5} #incomplete but enough for our purposes
}</p></div>
</dd>
<dt id="nuclear_gamma_tracker.automation4LISE.pixel_locations"><code class="name">var <span class="ident">pixel_locations</span></code></dt>
<dd>
<div class="desc"><p>An array of dictionaries (c++ maps). "data" is the key for the corresponding isotope and its value is an array of data.
Using zeros as place holders for intialization.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="nuclear_gamma_tracker.automation4LISE.FP_slit_X_transmission_percent"><code class="name flex">
<span>def <span class="ident">FP_slit_X_transmission_percent</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<p>Retrieve the transmission percent in the x direction at the focal plane. Incoming beam looks 'Gaussian' but
there is very litter dispersion in y direction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FP_slit_X_transmission_percent():
        &#34;&#34;&#34;Summary

        Retrieve the transmission percent in the x direction at the focal plane. Incoming beam looks &#39;Gaussian&#39; but 
        there is very litter dispersion in y direction.
        &#34;&#34;&#34;
        #NEED TO WORK ON THIS
        print(&#34;Getting FP_Slits X space transmission...&#34;)
        filename = str(desktop) + &#34;\data.txt&#34; #desktop comes from top of the sript.
        df = pd.read_csv(filename)
        FP_x_space_transmission = df.iloc[39,0] #location in the .csv file
        FP_x_space_transmission = FP_x_space_transmission.split()
        #print(FP_x_space_transmission[4])
        return FP_x_space_transmission[4] #percent value </code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.automation4LISE.get_intensity"><code class="name flex">
<span>def <span class="ident">get_intensity</span></span>(<span>isotope, beam_element, beam_mass)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<p>Retrieve the intensity based on the isotope you are interested in, the beam isotope (element) you are using, and the mass number
for the beam element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_intensity(isotope,beam_element,beam_mass):
        &#34;&#34;&#34;Summary

        Retrieve the intensity based on the isotope you are interested in, the beam isotope (element) you are using, and the mass number 
        for the beam element.
        &#34;&#34;&#34;
        flag = False
        print(isotope)
        #get pixel location of isotope on screen
        print(&#34;Retrieving intensity...&#34;)
        x = pixel_locations[isotope][&#34;x&#34;]
        y = pixel_locations[isotope][&#34;y&#34;]
        #print(x,y)
        pag.position()
        pag.moveTo(x,y)
        pag.click(button=&#34;right&#34;)
        pag.moveTo(1483,417) #File save button 
        pag.click()

        &#34;&#34;&#34;
        pag.moveTo(532,121) #drop down 
        pag.click()
        #pag.press(&#34;d&#34;,presses=2,interval=1) #to save in desktop
        pag.press(&#34;d&#34;,interval=1) #to save in desktop
        pag.press(&#34;enter&#34;)
        &#34;&#34;&#34;
        pag.moveTo(531,339) #file save text box
        pag.click()
        filename = str(desktop) + &#34;\data.txt&#34; #desktop comes from top of the sript.
        print(f&#34;The file is being saved at the following location: {filename}&#34;)
        pag.write(filename)
        #pag.write(&#34;junk.txt&#34;)
        pag.press(&#34;enter&#34;)
        pag.press(&#34;left&#34;)
        pag.press(&#34;enter&#34;) #this &#34;enter&#34; saves the file to desktop
        pag.moveTo(1563,44)
        pag.click()
        df = pd.read_csv(filename)
        #df = pd.read_csv(&#34;C:\\Users\Owner\Desktop\junk.txt&#34;) #path to temporary file. NEED TO UPDATE 
        #print(df)
        intensity_check=df.iloc[0,0]  #location of the intensity in the data frame. Usually included an extra line if it is zero
        intensity_check = intensity_check.split()
        print(intensity_check)
        if len(intensity_check) == 6:
                if intensity_check[5] == &#34;0!&#34;:
                        print(&#34;TRANSMISSION IS 0.0% WITH THIS PROJECTILE &#34;)
                        flag = True
                        return 0,flag 
        else: 
                _intensity=df.iloc[6,0] #location of the intensity in the data frame 
                _intensity=_intensity.split()
                print(f&#34;The intensity for {isotope} with {beam_element} {beam_mass} is {_intensity[4]}.&#34;) #intensity value
                return _intensity[4],flag</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.automation4LISE.get_thickness"><code class="name flex">
<span>def <span class="ident">get_thickness</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>To retrive the thickness of the target after optmizing. Optimizing is done by LISE++.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_thickness():
        &#34;&#34;&#34;To retrive the thickness of the target after optmizing. Optimizing is done by LISE++.&#34;&#34;&#34;
        target_thickness = 0
        pc.copy(&#34;&#34;) #clear clipboard
        print(&#34;Retrieving thickness...&#34;)
        pag.moveTo(453,38) #calculations 
        pag.click()
        pag.dragTo(504, 151,.5) #Optimum target
        time.sleep(.6)
        pag.moveTo(381,485) # first ok 
        pag.click()
        pag.moveTo(326,655) # second ok 
        pag.click()
        time.sleep(20)
        pag.moveTo(260,451) #load thickness
        pag.click()
        pag.moveTo(1629,160) #exit first plot
        pag.click()
        pag.moveTo(1600,93) #exit second plot
        pag.click()
        pag.moveTo(24,196) #target button 
        pag.click()
        pag.moveTo(477,286) #box containing info 
        time.sleep(1)
        pag.doubleClick()
        time.sleep(1)
        pag.hotkey(&#39;ctrl&#39; , &#39;c&#39;) #copy 
        time.sleep(1)
        target_thickness = pc.paste() #paste it to a variable 
        print(f&#34;Thickness is {target_thickness} microns&#34;)
        &#34;&#34;&#34;
        for i,m in enumerate(isotope_info):
                if isotope_info[i][&#34;isotope&#34;] == isotope_select:
                        isotope_info[i][&#34;thickness&#34;] = s
                        iso_name, iso_t = isotope_info[i][&#34;isotope&#34;] , isotope_info[i][&#34;thickness&#34;]
                        print(iso_name,iso_t)
        &#34;&#34;&#34;
        pag.moveTo(456,459) #ok button to close
        pag.click()
        return target_thickness </code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.automation4LISE.isotope_loop"><code class="name flex">
<span>def <span class="ident">isotope_loop</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Use to find the best beam for each isotope. However, it has already been determined that the best beam is Ca 48.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isotope_loop():
        &#34;&#34;&#34;Use to find the best beam for each isotope. However, it has already been determined that the best beam is Ca 48.&#34;&#34;&#34;
        beam_data = []
        start = time.time()
        df = pd.DataFrame(None) #create our data frame
        for i,dic in enumerate(isotope_info): #loop for fragments
                df = df[0:0]
                df = pd.DataFrame(columns=[&#34;Beam element&#34;,&#34;A (u)&#34;,&#34;Beam energy (MeV/u)&#34;,&#34;Beam Intensity (pnA)&#34;,&#34;Target thickness (microns)&#34;,&#34;Fragment Intensity (pnA)&#34;])
                data = [] 
                iso=dic[&#39;isotope&#39;].replace(&#34;_&#34;,&#34; &#34;) #get rid of the underscore in the isotope name
                print(f&#34;You are looking at the {iso} isotope.&#34;)  #returns the name of the isotope
                iso = iso.split()
                set_fragment(iso[0],iso[1]) #fragment name, mass number
                for i,beam_element in enumerate(beam_info): #now loop for all the provided beams
                        print(f&#34;You are using {beam_element} as your primary beam at {beam_info[beam_element][&#39;Energy&#39;]} MeV/u with {beam_info[beam_element][&#39;Intensity&#39;]} pnA.&#34;)
                        beam_energy= beam_info[beam_element][&#34;Energy&#34;]
                        beam_intensity=beam_info[beam_element][&#34;Intensity&#34;]
                        beam_element=beam_element.replace(&#34;_&#34;,&#34; &#34;)
                        beam_element=beam_element.split()
                        if beam_element[1] &lt;= iso[1]:
                                print(f&#34;Skipping {beam_element[0]} {beam_element[1]}. Not greater than {iso[1]} nucleons.&#34;)
                                continue
                        #                               name, energy, intensity, mass number A
                        set_projectile(beam_element[0],beam_energy,beam_intensity,beam_element[1])
                        thickness = get_thickness() #thickness with that particular beam for a particular fragment 
                        tune_spectrometer()
                        frag_intensity,flag = get_intensity(dic[&#39;isotope&#39;],beam_element[0],beam_element[1]) #pass the isotope name to get intensity and save it to the map with the frag info
                        if flag == True:
                                continue
                        print(f&#34;Data being appended in the following format -&gt; beam element, A,beam energy, beam intensity, thickness, fragment intensity: {beam_element[0]},{beam_element[1]} ,{beam_energy},{beam_intensity},{thickness}, {frag_intensity}&#34;)
                        df.loc[i] = [beam_element[0],beam_element[1],beam_energy,beam_intensity,thickness,frag_intensity]
                        print(df)
                print(f&#34;DATA FRAME FOR {iso[0]} {iso[1]} ISOTOPE.&#34;)
                print(df)
                df.to_csv(f&#34;{iso[0]}_{iso[1]}_data_LISE++.csv&#34;)
                print(f&#34;File saved as: {iso[0]}_{iso[1]}_data_LISE++.csv&#34;)
        end = time.time()
        print(f&#34;It took {end-start} to run everything.&#34;)</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.automation4LISE.isotope_tuning_values"><code class="name flex">
<span>def <span class="ident">isotope_tuning_values</span></span>(<span>FP_slit_width, isotope_start, isotope_end, wedge_range)</span>
</code></dt>
<dd>
<div class="desc"><p>To find the best configuration using a Ca 48 beam.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isotope_tuning_values(FP_slit_width,isotope_start,isotope_end,wedge_range):
        &#34;&#34;&#34;To find the best configuration using a Ca 48 beam.&#34;&#34;&#34;
        set_projectile(&#34;Ca&#34;,140,80,48) #set the beam here with element name, energy, intensity, atomic number 
        start = time.time()
        set_FP_slits(FP_slit_width)
        #if bool_value == True: #if you want to start from  a particular isotope
        new_isotope_dic = slice_array(isotope_info,isotope_start)
        for i,dic in enumerate(new_isotope_dic): #loop for each fragment
                df = pd.DataFrame(None) #create our data frame
                df = pd.DataFrame(columns=[&#34;I_2 slit width (mm) &#34;,&#34;Intensity (pps) &#34;,&#34;Target thickness (microns) &#34;,&#34;Horizontal FP Slit width (mm)&#34;,&#34;Purity transmission % &#34;,&#34;Mom. Accpetance % &#34;, &#34;Wedge thickness (microns) &#34;,&#34;wedge angle (mrad)&#34;])
                iso=dic[&#39;isotope&#39;].replace(&#34;_&#34;,&#34; &#34;) #get rid of the underscore in the isotope name
                print(f&#34;You are looking at the {iso} isotope.&#34;)  #returns the name of the isotope
                iso = iso.split()
                set_fragment(iso[0],iso[1])
                #wedge_thickness = 2300 #wedge thickness to start with 
                for count,wedge_thickness in enumerate(wedge_range): #loop over each wedge thickness
                        print(f&#34;Currently using {wedge_thickness} microns for {iso[0]} {iso[1]}&#34;)
                        tune_spectrometer()
                        preliminary_wedge_angle = set_I2_wedge(str(wedge_thickness))    # There is a dependence between target and wedge. Doing it twice gives best results 
                        tune_spectrometer()
                        preliminary_target_thickness = get_thickness()
                        tune_spectrometer()
                        wedge_angle = set_I2_wedge(str(wedge_thickness))
                        wedge_angle = &#34;-&#34; + wedge_angle                                 
                        tune_spectrometer()
                        target_thickness = get_thickness()
                        tune_spectrometer()
                        frag_intensity,flag = get_intensity(dic[&#39;isotope&#39;],&#34;Ca&#34;,48) #pass the isotope name to get intensity and save it to the map with the frag info
                        if flag == True: #if we have zero transmission, skip that wedge thickness
                                continue
                        #FP_x_space_transmission = FP_slit_X_transmission_percent()
                        _purity_percent = purity_percent(iso[0] + iso[1]) #pass in the name of the fragment isotope
                        print(f&#34;Purity is {_purity_percent}&#34;)
                        df.loc[count] = [29.5,frag_intensity,target_thickness,FP_slit_width,_purity_percent,1,wedge_thickness,wedge_angle] #harcode the 1% momentum acceptance
                        wedge_thickness=wedge_thickness+100
                        print(f&#34;Have gone through {count} iterations&#34;)
                        print(df)
                df.to_csv(f&#34;{iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)
                print(f&#34;File saved as: {iso[0]}_{iso[1]}_finetune_{FP_slit_width}_data_LISE++.csv&#34;)
                del df 
                if(dic[&#39;isotope&#39;] == isotope_end):
                        print(f&#34;YOU HAVE REACHED {isotope_end}!&#34;)
                        break
        end = time.time()
        print(f&#34;It took {(end-start)/60.0} minutes to run everything.&#34;)</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.automation4LISE.notes"><code class="name flex">
<span>def <span class="ident">notes</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>General Notes: </p>
<p>If program is not open, look for the program image on deskotp, and click on it. </p>
<p>Note: Could improve by having it go directly to the LISE++.exe file and executing it. Could do this
with a shell script or here (in the python script).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notes():
        &#34;&#34;&#34;General Notes: 

        If program is not open, look for the program image on deskotp, and click on it. 

        Note: Could improve by having it go directly to the LISE++.exe file and executing it. Could do this 
        with a shell script or here (in the python script).

        &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.automation4LISE.purity_percent"><code class="name flex">
<span>def <span class="ident">purity_percent</span></span>(<span>fragment_isotope)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<p>Retrieve the overall purity for the fragment you are studying after passinng through the FP_PIN (focal plane Particle in) detector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def purity_percent(fragment_isotope):
        &#34;&#34;&#34;Summary
        
        Retrieve the overall purity for the fragment you are studying after passinng through the FP_PIN (focal plane Particle in) detector.
        
        &#34;&#34;&#34;
        print(f&#34;Retrieving beam purity for {fragment_isotope}...&#34;)
        pag.moveTo(832,83) #run all nucleo buttom (red lightning bolt)
        pag.click()
        time.sleep(40)
        pag.moveTo(999,77) #x spatial distribution 
        pag.click()
        pag.dragTo(1110, 629,.5) #FP_PIN detector
        pag.click(interval=.5) 
        time.sleep(4)
        pag.moveTo(14,316) #stats box
        pag.click()
        pag.press(&#34;enter&#34;) #accept
        time.sleep(1)
        pag.moveTo(1609,201) #file save button
        pag.click()
        &#34;&#34;&#34;
        pag.moveTo(365,195) #drop down 
        pag.click()
        #pag.press(&#34;d&#34;,presses=2,interval=1) #to save in desktop
        pag.press(&#34;d&#34;,interval=1) #to save in desktop
        pag.press(&#34;enter&#34;)
        &#34;&#34;&#34;
        pag.moveTo(389,413) #file save text box
        pag.click()

        filename = str(desktop) + &#34;\pps_data.txt&#34; #desktop comes from top of the sript.
        print(f&#34;The file is being saved at the following location: {filename}&#34;)
        pag.write(filename)

        #pag.write(&#34;pps_junk.txt&#34;)
        pag.press(&#34;enter&#34;) #save file
        pag.press(&#34;left&#34;)
        pag.press(&#34;enter&#34;) #this &#34;enter&#34; saves the file to desktop
        pag.moveTo(1682,122)
        pag.click()
        pag.moveTo(1877,13)
        pag.click()
        df = pd.read_csv(filename,error_bad_lines=False)
        #df = pd.read_csv(&#34;C:\\Users\Owner\Desktop\pps_junk.txt&#34;,error_bad_lines=False) #path to temporary file. NEED TO UPDATE
        print(f&#34;Size of data frame is {df.size}.&#34;)
        _string = df.iloc[5,0] #get the pps for isotope in question
        _string = _string.split()
        isotope_fragment = _string[13] #grab pps value
        total = 0.
        for i in range(5,df.size): 
                string = df.iloc[i,0]
                string = string.split()
                val = float(float(string[13])) #to get it to correct scientific notation
                total = total + val
        print(f&#34;The total amount of pps is {total}.&#34;)
        frag_val = float(float(isotope_fragment))
        print(f&#34;Percent of {fragment_isotope} in beam is {(float(float(frag_val))/total)*100.} %&#34;)
        percent =(float(float(frag_val))/total)*100.
        return percent</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.automation4LISE.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the thickness to a text file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save():
        &#34;&#34;&#34;Save the thickness to a text file.&#34;&#34;&#34;
        with open(&#34;thickness.txt&#34;,&#34;w&#34;) as file:
                file.write(json.dumps(isotope_info))
        file.close()</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.automation4LISE.set_FP_slits"><code class="name flex">
<span>def <span class="ident">set_FP_slits</span></span>(<span>slit_width)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<p>Sets the the distance of the focal plane slits. The slit_width is passed in as the argument.
Important to set the appropriate Focal Plane (FP) slits to be able to achieve a compromise
between the purity of the beam and yield.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_FP_slits(slit_width):
        &#34;&#34;&#34;Summary
        
        Sets the the distance of the focal plane slits. The slit_width is passed in as the argument. 
        Important to set the appropriate Focal Plane (FP) slits to be able to achieve a compromise
        between the purity of the beam and yield.

        &#34;&#34;&#34;
        print(&#34;Setting FP_Slits...&#34;)
        pag.moveTo(65,684) #move to slit button 
        pag.click()
        pag.moveTo(764,231)
        pag.click()
        pag.write(str(slit_width))
        pag.moveTo(238,447)
        pag.click()
        pag.moveTo(71,744)
        pag.click()</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.automation4LISE.set_I2_wedge"><code class="name flex">
<span>def <span class="ident">set_I2_wedge</span></span>(<span>wedge_thickness)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<p>Use to set the thickness of the wedge at the second image plane 'I2'. Important due to the magnets
adjusting to the wedge with the appropriate Brho value to maximize the transmission of the fragment
you are interested and reduce the amount of contaminants.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_I2_wedge(wedge_thickness):
        &#34;&#34;&#34;Summary

        Use to set the thickness of the wedge at the second image plane &#39;I2&#39;. Important due to the magnets 
        adjusting to the wedge with the appropriate Brho value to maximize the transmission of the fragment 
        you are interested and reduce the amount of contaminants.

        &#34;&#34;&#34;
        print(&#34;Setting I2_wedge...&#34;)
        pag.moveTo(60,461) #move to wedge button 
        pag.click()
        pag.write(str(wedge_thickness))
        pag.moveTo(926,223) #set spectrometer after block
        pag.click()
        time.sleep(2)
        pag.moveTo(397,398) #select wedge profile
        pag.click()
        pag.moveTo(881,394) #move to calculate angle 
        pag.click()
        time.sleep(10) #wait 
        pag.moveTo(371,479) #fit achromatic angle from LISE calc.
        pag.click()
        pag.moveTo(308,530) #select the angle and copy 
        pag.doubleClick()
        pc.copy(&#34;&#34;)
        time.sleep(2)
        pag.hotkey(&#39;ctrl&#39;,&#39;c&#39;) #done twice due to bug in not properly copying. This fixes that bug.
        time.sleep(1)
        pag.hotkey(&#39;ctrl&#39;,&#39;c&#39;)
        angle = pc.paste()
        pag.moveTo(168,622) #ok button 
        pag.click()
        pag.moveTo(152,535)
        pag.click()
        print(f&#34;The angle for the wedge is -{angle}.&#34;)
        return str(angle)</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.automation4LISE.set_fragment"><code class="name flex">
<span>def <span class="ident">set_fragment</span></span>(<span>fragment, A)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<p>Set the fragment you are interested in studying. Pass in the name of the fragment and mass number A.
This is handled automatically in the loop, no need to set it yourself (besided debugging/upgrading reasons).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fragment(fragment,A):
        &#34;&#34;&#34;Summary

        Set the fragment you are interested in studying. Pass in the name of the fragment and mass number A.
        This is handled automatically in the loop, no need to set it yourself (besided debugging/upgrading reasons).

        &#34;&#34;&#34;
        print(&#34;Setting fragment...&#34;)
        pag.moveTo(20,170) #projectile button 
        pag.click()
        pag.moveTo(250,463) #element text box
        pag.doubleClick()
        #pag.press(&#34;delete&#34;)
        pag.write(str(A))
        pag.moveTo(309,470) #element text box
        pag.doubleClick()
        #pag.press(&#34;delete&#34;)
        pag.write(fragment)
        pag.moveTo(624,521) #energy
        pag.click()
        time.sleep(1)</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.automation4LISE.set_projectile"><code class="name flex">
<span>def <span class="ident">set_projectile</span></span>(<span>projectile_name, energy, intensity, A)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<p>Set the incoming projectile in LISE++ based on the projectiles name, energy, intensity, and atomic number (mass) A.
Passed in to the arguments in the following order: projectile_name, energy, intensity, A.</p>
<p>Current list of isotopes that can be used for target can be found at:
<a href="https://nscl.msu.edu/users/beams.html">https://nscl.msu.edu/users/beams.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_projectile(projectile_name,energy,intensity,A):
        &#34;&#34;&#34;Summary

        Set the incoming projectile in LISE++ based on the projectiles name, energy, intensity, and atomic number (mass) A.
        Passed in to the arguments in the following order: projectile_name, energy, intensity, A.

        Current list of isotopes that can be used for target can be found at:
        https://nscl.msu.edu/users/beams.html

        &#34;&#34;&#34;
        print(&#34;Setting projectile...&#34;)
        pag.moveTo(16,124) #projectile button 
        pag.click()
        pag.moveTo(262,213) #element text box
        pag.doubleClick()
        pag.write(projectile_name)
        pag.moveTo(231,211) # The mass number box
        pag.doubleClick()
        pag.write(str(A))
        pag.moveTo(519,213) #energy
        pag.doubleClick()
        pag.write(str(energy))
        pag.moveTo(523,421) #beam intensity 
        pag.doubleClick()
        pag.write(str(intensity))
        pag.moveTo(269,445)
        pag.click()
        time.sleep(1)</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.automation4LISE.show_pixels"><code class="name flex">
<span>def <span class="ident">show_pixels</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the pixel location on your screen as you move your cursor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_pixels():
        &#34;&#34;&#34;Show the pixel location on your screen as you move your cursor.&#34;&#34;&#34;
        print(&#39;Press Ctrl-C to quit.&#39;)
        try:
                while True:
                        x, y = pag.position()
                        positionStr = &#39;X: &#39; + str(x).rjust(4) + &#39; Y: &#39; + str(y).rjust(4)
                        print(positionStr, end=&#39;&#39;)
                        print(&#39;\b&#39; * len(positionStr), end=&#39;&#39;, flush=True)
        except KeyboardInterrupt:
                print(&#39;\n&#39;)</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.automation4LISE.slice_array"><code class="name flex">
<span>def <span class="ident">slice_array</span></span>(<span>arr, start)</span>
</code></dt>
<dd>
<div class="desc"><p>Summary</p>
<p>To "slice" an array of dictionaries and return sliced array.</p>
<p>Function to slice an array. Pass in the array and where you want to beginn slicing from.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_array(arr,start):
        &#34;&#34;&#34;Summary

        To &#34;slice&#34; an array of dictionaries and return sliced array.

        Function to slice an array. Pass in the array and where you want to beginn slicing from. 
        &#34;&#34;&#34;
        new_array = []
        index =0
        for i,dic in enumerate(arr):
                temp_dic = arr[i] #grab individual dictionary in that specific array index
                if temp_dic[&#34;isotope&#34;] == str(start): #if starting isotope is found, save the index location
                        index =i
                        break
        for t in range(index,len(arr)):
                new_array.append(arr[t])
        return new_array #return a sliced array containing dictionaries from starting isotope</code></pre>
</details>
</dd>
<dt id="nuclear_gamma_tracker.automation4LISE.tune_spectrometer"><code class="name flex">
<span>def <span class="ident">tune_spectrometer</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Tune the overall spectrometer to optimize transmission. Done by LISE++.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tune_spectrometer():
        &#34;&#34;&#34;Tune the overall spectrometer to optimize transmission. Done by LISE++.&#34;&#34;&#34;
        print(&#34;Tuning spectrometer...&#34;)
        pag.moveTo(335,78)
        pag.click()
        time.sleep(1)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nuclear_gamma_tracker" href="index.html">nuclear_gamma_tracker</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="nuclear_gamma_tracker.automation4LISE.beam_info" href="#nuclear_gamma_tracker.automation4LISE.beam_info">beam_info</a></code></li>
<li><code><a title="nuclear_gamma_tracker.automation4LISE.pixel_locations" href="#nuclear_gamma_tracker.automation4LISE.pixel_locations">pixel_locations</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="nuclear_gamma_tracker.automation4LISE.FP_slit_X_transmission_percent" href="#nuclear_gamma_tracker.automation4LISE.FP_slit_X_transmission_percent">FP_slit_X_transmission_percent</a></code></li>
<li><code><a title="nuclear_gamma_tracker.automation4LISE.get_intensity" href="#nuclear_gamma_tracker.automation4LISE.get_intensity">get_intensity</a></code></li>
<li><code><a title="nuclear_gamma_tracker.automation4LISE.get_thickness" href="#nuclear_gamma_tracker.automation4LISE.get_thickness">get_thickness</a></code></li>
<li><code><a title="nuclear_gamma_tracker.automation4LISE.isotope_loop" href="#nuclear_gamma_tracker.automation4LISE.isotope_loop">isotope_loop</a></code></li>
<li><code><a title="nuclear_gamma_tracker.automation4LISE.isotope_tuning_values" href="#nuclear_gamma_tracker.automation4LISE.isotope_tuning_values">isotope_tuning_values</a></code></li>
<li><code><a title="nuclear_gamma_tracker.automation4LISE.notes" href="#nuclear_gamma_tracker.automation4LISE.notes">notes</a></code></li>
<li><code><a title="nuclear_gamma_tracker.automation4LISE.purity_percent" href="#nuclear_gamma_tracker.automation4LISE.purity_percent">purity_percent</a></code></li>
<li><code><a title="nuclear_gamma_tracker.automation4LISE.save" href="#nuclear_gamma_tracker.automation4LISE.save">save</a></code></li>
<li><code><a title="nuclear_gamma_tracker.automation4LISE.set_FP_slits" href="#nuclear_gamma_tracker.automation4LISE.set_FP_slits">set_FP_slits</a></code></li>
<li><code><a title="nuclear_gamma_tracker.automation4LISE.set_I2_wedge" href="#nuclear_gamma_tracker.automation4LISE.set_I2_wedge">set_I2_wedge</a></code></li>
<li><code><a title="nuclear_gamma_tracker.automation4LISE.set_fragment" href="#nuclear_gamma_tracker.automation4LISE.set_fragment">set_fragment</a></code></li>
<li><code><a title="nuclear_gamma_tracker.automation4LISE.set_projectile" href="#nuclear_gamma_tracker.automation4LISE.set_projectile">set_projectile</a></code></li>
<li><code><a title="nuclear_gamma_tracker.automation4LISE.show_pixels" href="#nuclear_gamma_tracker.automation4LISE.show_pixels">show_pixels</a></code></li>
<li><code><a title="nuclear_gamma_tracker.automation4LISE.slice_array" href="#nuclear_gamma_tracker.automation4LISE.slice_array">slice_array</a></code></li>
<li><code><a title="nuclear_gamma_tracker.automation4LISE.tune_spectrometer" href="#nuclear_gamma_tracker.automation4LISE.tune_spectrometer">tune_spectrometer</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>